extends base

append head
    title D Programming Language Version #{thisVersion} Change Log

append content
    header
        h1 Change Log &ndash; v#{thisVersion}

    |!= h2(toc, "compiler-changes", "Compiler Changes")

    |!= h3(toc, "extensionless", "Executing Source Files With Extensions")

    p
        | On Posix systems it is frequently useful to have a shebang
        | line at the start of an extensionless file, which marks the tool
        | used to compile the script. It's now possible to use this
        | technique with D, e.g. the following is a D source file with the
        | file name "<strong>my-script</strong>":

    code
        pre
            | #!rdmd
            |
            | void main()
            | {
            | }

    p
        | <strong>Note:</strong> This does not allow an arbitrary extension,
        | as D source files need to be proper D identifiers.

    p
        | <strong>Note:</strong> This feature is not available on Windows,
        | as Windows does not have extensionless executable files.

    p
        | <strong>Note:</strong> When compiling, and in order to avoid the
        | default behavior of generating an extensionless executable which
        | would overwrite the source file, the compiler will generate
        | "<em>a.out</em>" instead.

    |!= h3(toc, "goto-variables", "goto Can't Skip Variable Declarations")

    p
        | <strong>goto</strong> can no longer skip variable declarations.
        | For a very long period, the following code had been allowed
        | by mistake, but it is prohibited now:

    code
        pre
            | import std.stdio;
            |
            | void main()
            | {
            |     // Error: goto skips declaration of variable v
            |     goto Label;
            |
            |     int v = 42;
            |
            | Label:
            |     writeln(v);
            | }

    |!= h3(toc, "inferred-attributes", "Inferred Attributes")

    p
        | Regardless of how directly or indirectly a function is
        | instantiated, its attributes will still be inferred:

    code
        pre
            | struct S(T)
            | {
            |     T square(T x)
            |     {
            |         T calc()
            |         {
            |             return x * x;
            |         }
            |         return calc();
            |     }
            |
            |     static double pi() { return 3.141592; }
            | }
            |
            | void main() pure @safe nothrow
            | {
            |     S!int s;
            |
            |     // S!int.square and its nested function calc
            |     // are instantiated functions, so their attributes
            |     // are inferred as pure and callable from main():
            |     assert(s.square(2) == 4);
            |
            |     // static member function attributes are also inferred now
            |     auto pi = typeof(s).pi();
            | }

    |!= h3(toc, "inout-const", "inout const")

    p A new type qualifier of <strong>inout const</strong> was added.

    p
        | Until now, the common type of <strong>immutable(T)</strong> and
        | <strong>inout(T)</strong> had been <strong>const(T)</strong>.
        | But that loses the <strong>inout</strong> information, which
        | might then refuse some valid code. Now the type becomes
        | <strong>inout(const(T))</strong>, which meaningfully propagates
        | the appropriate type qualifier.

    code
        pre
            | inout(const(int))[]
            | foo(bool condition, inout(int)[] x, immutable(int)[] y)
            | {
            |     static assert(
            |         is(typeof(condition ? x : y) == inout(const(int))[])
            |     );
            |
            |     return condition ? x : y;
            | }
            |
            | void main()
            | {
            |     int[] marr = [1,2,3];
            |     const(int)[] carr = [4,5,6];
            |     immutable(int)[] iarr = [7,8,9];
            |
            |     // inout(const(int))[] can go back to const(int)[]
            |     // or back to immutable(int)[].
            |     static assert(
            |         is(typeof(foo(true, marr, iarr)) == const(int)[])
            |     );
            |
            |     static assert(
            |         is(typeof(foo(true, carr, iarr)) == const(int)[])
            |     );
            |
            |     static assert(
            |         is(typeof(foo(true, iarr, iarr)) == immutable(int)[])
            |     );
            | }

    |!= h3(toc, "entire-tuple-slicing", "Entire Tuple Slicing")

    p
        - bugLink(8244);
        | &mdash; cannot slice a type tuple with '[]' in locations
        | where a type is valid:

    code
        pre
            | import std.typetuple;
            | alias Types = TypeTuple!(int, double, string);
            |
            | // Was error in 2.064, but allowed from 2.065.
            | alias Types2 = Types[];
            | static assert(is(Types == Types2));

    |!= h3(toc, "modules-have-no-type", "Modules Have No Type")

    p
        - bugLink(9081);
        | &mdash; Modules shouldn't have a type

    code
        pre
            | import std.stdio;
            |
            | // Both had printed 'void' in 2.064.
            | // From 2.065, both will cause "has no type" error.
            | pragma(msg, typeof(std));
            | pragma(msg, typeof(std.stdio));

    p
        | By the change, an idiom that used to work
        | <strong>is(typeof(package_or_module_name))</strong> is changed to
        | not work. Instead use:
        | <strong>__traits(compiles, package_or_module_name)</strong>.

    |!= h3(toc, "const-immutable-field-initializers-deprecated", "const/immutable Field Initializers Deprecated")

    p
        | const and immutable fields with initializers are now deprecated.
        | Eventually, they will be changed to occupy space in the object.
        | Such fields should now be changed to enum or static. See also the
        a(href="/changelog/2.063#const-immutable-warn") release note in 2.063
        | .

    p
        | Related to that, void-initialized const or immutable fields will
        | now occupy space in the object instance ahead of schedule:

    code
        pre
            | struct S
            | {
            |     const int[1000] x = void;
            |
            |     this(int n)
            |     {
            |         // Was disallowed in 2.064.
            |         // From 2.065 x is a field of runtime object.
            |         x[] = n;
            |     }
            | }
            |
            | // S.sizeof had been 1 in 2.064.
            | // From 2.065, field s.x occupies space in the object.
            | static assert(S.sizeof == int.sizeof * 1000);
            |
            | void main()
            | {
            |     S s = S(3);
            |
            |     foreach (e; s.x)
            |     {
            |         // OK
            |         assert(e == 3);
            |     }
            | }

    |!= h3(toc, "unordered-comparisons-deprecated", "Unordered Comparisons Deprecated")

    p
        - bugLink(10369);
        | Deprecate unordered floating point comparisons

    |!= h3(toc, "deprecate-min-for-floating-point", "Deprecate .min for Floating Point")

    p
        - bugLink(10469);
        | Deprecate float.min, double.min, real.min

    |!= h3(toc, "ctfe-overlapped-unions", "CTFE and Overlapped Unions")

    p
        abbr(title="Compile Time Function Execution") CTFE
        | can now handle overlapped union fields:

    code
        pre
            | union U
            | {
            |     size_t x;
            |     int* y;
            | }
            |
            | bool test()
            | {
            |     U u;
            |     assert(u.x == 0);
            |     // In here, reading u.y will cause CTFE error.
            |
            |     u.y = [1,2,3].ptr;
            |     // Writing value to overlapped field u.y
            |     // will make corresponding field u.x invalid.
            |
            |     assert(u.y[0..3] == [1,2,3]);
            |     // u.y holds valid field and reading it is allowed
            |     // In here, reading u.x will cause CTFE error.
            |
            |     u.x = 10;
            |     // Set value to u.x again.
            |     assert(u.x == 10); // OK
            |     // In here, reading u.y will cause CTFE error.
            |
            |     return true;
            | }
            |
            | // run CTFE
            | static assert(test());

    |!= h3(toc, "getaliasthis-trait", "getAliasThis Trait")

    p
        | The new <strong>getAliasThis</strong> trait will return a tuple of
        | field names which are marked as the
        a(href="/class#AliasThis") subtypes
        | of an aggregate type. For example:

    code
        pre
            | struct S
            | {
            |     string var;
            |     alias var this;
            | }
            |
            | static assert(__traits(getAliasThis, S)[0] == "var");

    p
        | <strong>Note:</strong> Multiple subtyping is not yet implemented in
        | D, therefore this trait will always return a tuple of length 1.

    |!= h2(toc, "library-changes", "Library Changes")

    |!= h3(toc, "std-algorithm-predicate-functions", "std.algorithm Predicate Functions")

    p
        | Functions such as
        a(href="/phobos/std_algorithm#any") any,
        a(href="/phobos/std_algorithm#all") all,
        a(href="/phobos/std_algorithm#canFind") canFind,
        | and
        a(href="/phobos/std_algorithm#equal") equal,
        | are now templates, which allows them to be used as predicates to
        | other templates, as well as allowing the user to alias an
        | instantiation of any such templates. For an example of how this
        | allows terser syntax in user-code, in the following example the
        | programmer wants to check whether all the strings in a string array
        | have at least one ASCII digit:

    code
        pre
            | import std.algorithm : all;
            | import std.ascii : isDigit;
            |
            | void main()
            | {
            |     string[] inputs = ["foo1", "bar2"];
            |
            |     bool allContainDigit;
            |     foreach (input; inputs)
            |     {
            |         // none of the characters are ASCII digits
            |         if (!any!isDigit(input))
            |         {
            |             allContainDigit = false;
            |             break;
            |         }
            |     }
            | }

    p
        | But it is now simpler to use the any template itself as a predicate.
        | We can make it a predicate to another useful template, the all
        | template:

    code
        pre
            | import std.algorithm : any, all;
            | import std.ascii : isDigit;
            |
            | void main()
            | {
            |     string[] inputs = ["foo1", "bar2"];
            |     bool allContainDigit = all!(any!isDigit)(inputs);
            | }

    p
        | In addition to allowing these functions to become predicates they
        | can now also be aliased, which allow you to make your functions
        | simpler to understand:

    code
        pre
            | import std.algorithm : any, all;
            | import std.ascii : isDigit;
            |
            | void main()
            | {
            |     // less visual noise and a self-describing function
            |     alias isAnyDigit = any!isDigit;
            |
            |     string[] inputs = ["foo1", "bar2"];
            |     // easier to understand
            |     bool allContainDigit = all!isAnyDigit(inputs);
            |
            |     // or wrap the entire algorithm into one symbol!
            |     alias doAllContainDigits = all!isAnyDigit;
            |
            |     // self-describing code
            |     assert( doAllContainDigits(["1", "a 1", "b 2"]));
            |     assert(!doAllContainDigits(["c", "a 1", "b 2"]));
            | }

    p
        | You can of course combine <strong>all</strong> and
        | <strong>any</strong> in a number of combinations. For example,
        | if you want to reverse the test and instead check whether
        | <strong>any</strong> of the strings in the string array contain
        | <strong>all</strong> digits, the code might look like the following:

    code
        pre
            | import std.algorithm : any, all;
            | import std.ascii : isDigit;
            |
            | void main()
            | {
            |     alias areAllDigits = all!isDigit;
            |
            |     alias areAnyIntegrals = any!areAllDigits;
            |
            |     assert( areAnyIntegrals(["123", "456"]));
            |     // "123" is a number
            |     assert( areAnyIntegrals(["abc", "123"]));
            |     // "def123" is not really a number
            |     assert(!areAnyIntegrals(["abc", "def123"]));
            | }

    p
        | If on the other hand you want to ensure that <strong>all</strong>
        | strings in the string array contain <strong>all</strong> digits,
        | the code might look like the following:

    code
        pre
            | import std.algorithm : any, all;
            | import std.ascii : isDigit;
            |
            | void main()
            | {
            |     alias areAllDigits = all!isDigit;
            |
            |     alias allStringsDigits = all!areAllDigits;
            |
            |     assert( allStringsDigits(["123", "456"]));
            |     // "123" is a number, but "abc" is not
            |     assert(!allStringsDigits(["abc", "123"]));
            | }

    |!= h3(toc, "std-algorithm-all-no-predicate", "std.algorithm.all Without a Predicate")

    p
        | You no longer need to pass a predicate if you want to match all
        | items in a range which implicitly convert to <strong>true</strong>:

    code
        pre
            | import std.algorithm;
            |
            | void main()
            | {
            |     auto arr1 = [true, true, true];
            |     // all values are true
            |     assert( all(arr1));
            |
            |     auto arr2 = [false, true, true];
            |     // all values are not true
            |     assert(!all(arr2));
            |
            |     auto arr3 = [1, 2, 3];
            |     // all values convert to true
            |     assert( all(arr3));
            |
            |     auto arr4 = [0, 2, 3];
            |     // all values do not convert to true
            |     assert(!all(arr4));
            | }

    |!= h3(toc, "bygrapheme-and-bycodepoint", "byGrapheme and byCodePoint")

    p
        | Complementary higher-order ranges which enable range operations
        | on graphemes:

    code
        pre
            | import std.array : array;
            | import std.range : retro;
            | import std.string : text;
            | import std.uni : byCodePoint, byGrapheme;
            |
            | void main()
            | {
            |     // noël
            |     string s = "noe\u0308l";
            |     // reverse it and convert the result back to UTF-8
            |     string reverse = s.byGrapheme()
            |         .array()
            |         .retro()
            |         .byCodePoint()
            |         .text();
            |
            |     // lëon
            |     assert(reverse == "le\u0308on");
            | }

    p
        | <strong>Note: byGrapheme</strong> will support bidirectionality in
        | the future, obviating the need for <strong>array</strong> in the
        | above example.

    |!= h3(toc, "multiple-arguments-for-only", "Multiple Arguments for 'only'")

    p
        a(href="/phobos/std_range#only") only
        | can now be used with more than one argument:

    code
        pre
            | import std.algorithm : joiner;
            | import std.range : equal, only;
            |
            | void main()
            | {
            |     assert(
            |         only("one", "two", "three")
            |         .joiner(" ")
            |         .equal("one two three")
            |     );
            | }

    p Additionally, <strong>only()</strong> is now a way to get an empty range.

    |!= h2(toc, "linker-changes", "Linker Changes")

    |!= h3(toc, "largeaddressaware", "/LARGEADDRESSAWARE")

    p /LARGEADDRESSAWARE has been added to the Win32 Optlink linker.

    p
        | When using the default Optlink linker on win32 (for linking
        | 32-bit object files and executables), the
        | <strong>/LARGEADDRESSAWARE</strong> option tells the linker that
        | the application can handle addresses larger than 2 gigabytes.
        | This is equivalent to Visual C's
        a(href="http://msdn.microsoft.com/en-us/library/wz223b1z.aspx") linker option
        | of the same name since this is an operating-system feature that
        | is enabled by setting a specific flag in the executable.

    |!= h2(toc, "dmd-compiler-regressions", "DMD Compiler Regressions Fixed")

    ol
        - bugItem(7782, "[ICE] With wrong import syntax");
        - bugItem(9107, "Value Range Analysis with uint and byte");
        - bugItem(9639, "Recursive template instanciation segfault dmd");
        - bugItem(11078, "Diagnostic for wrong RHS in property assign of a property group should improve");
        - bugItem(11321, "Can't link _D6object15__T7reserveTyaZ7reserveFNaNbNeKAyamZm");
        - bugItem(11441, "DMD halts compilation at semantic3");
        - bugItem(11447, "Closure provide bogus values");
        - bugItem(11472, "REGRESSION(2.064): dmd segfaults on wrong code instead of giving error");
        - bugItem(11487, "dmd segfaults on writefln in nested template");
        - bugItem(11504, "[CTFE] JSONValue cannot make in CTFE");
        - bugItem(11505, "Bad error message: \"opAssign [...] is annotated with @disable\"");
        - bugItem(11508, "[REG 2.064] Wrong code with -O on x86_64 for char comparisons");
        - bugItem(11513, "[REG 2.064] Assertion in module.c");
        - bugItem(11525, "REG(2.065): Error: 'a[] *= a[]' each element is not a scalar, it is a Complex!double");
        - bugItem(11553, "dmd segfault with recursive template");
        - bugItem(11554, "`is(T == enum);` produces an error if T is an enum defined with no members");
        - bugItem(11563, "Module dependency cycle causes unrelated template instantiations to fail");
        - bugItem(11566, "ICE with invalid array op");
        - bugItem(11596, "Internal error: backend/cgcs.c 351");
        - bugItem(11610, "Compiler core dumps on FreeBSD, compiles forever on Linux");
        - bugItem(11614, "Error: this for _expand_field_0 needs to be type Tuple not type Foo");
        - bugItem(11626, "[ICE] (mtype.c line 9718) With missing in ref type");
        - bugItem(11659, "false positive goto skips initialization of variable error (skipping enum initialization)");
        - bugItem(11718, "[REG2.065a] Unintended mangled names conflict of nested template structs");
        - bugItem(11723, "Too many \"integer overflow\" errors");
        - bugItem(11730, "associative array with Nullable!SysTime values: Called `get' on null Nullable!SysTime.");
        - bugItem(11751, "[REG2.065a] Hex float exponents should be decimal");
        - bugItem(11755, "Operator <>= and !<>= with arrays make internal error in e2ir");
        - bugItem(11767, "doubly mixed-in struct \"failed semantic analysis\"");
        - bugItem(11776, "[ICE] Assertion failure: 'tf->next == NULL' on line 119 in file 'mangle.c'");
        - bugItem(11777, "[ICE] dmd memory corruption as `Scope::pop` `free`s `fieldinit` used also in `enclosing`");
        - bugItem(11805, "Removal of Bool has critically broken expression evaluation");
        - bugItem(11818, "Ternary operator not allowed in a value parameter anymore");
        - bugItem(11822, "`-de` switch causees ICE with `auto` return and other stuff");
        - bugItem(11824, "A stack variable escaping problem in CTFE Phobos code");
        - bugItem(11844, "ICE(template.c:6643) Assertion failed: (td->semanticRun != PASSinit)");
        - bugItem(11849, "Recursive enum causes segfault");
        - bugItem(11850, "[ICE] Problem with filter with signed-unsigned array comparison");
        - bugItem(11852, "RDMD broken on the Github HEAD");
        - bugItem(11854, "Git-head does not build with Visual Studio");
        - bugItem(11863, "std.conv.to!string(int/uint, radix) returns incorrect string");
        - bugItem(11868, "ICE(template.c) on passing `inout const` argument as TemplateTupleParameter");
        - bugItem(11896, "[REG2.066a] isVirtualMethod related GitHub HEAD regression (works with 2.064)");
        - bugItem(11914, "Missed tuple unpacking in foreach for cartesianProduct");
        - bugItem(11919, "GitHub HEAD regression for getAttributes trait (DMD CORE DUMP)");
        - bugItem(11922, "[REG2.065a] ICE on nonexistent identifier in templated auto method");
        - bugItem(11924, "inout Variadic Template Parameters");
        - bugItem(11925, "[2.065] [REGRESSION] ICE in CompoundStatement::semantic");
        - bugItem(11930, "Github regression -- Alias this not considered in is(T unused: U) matching");
        - bugItem(11931, "Linkers \"Symbol Undefined\" again with dmd HEAD when -g specified");
        - bugItem(11941, "Errors when appending to aggregate member array in CTFE");
        - bugItem(11956, "dmd doesn't lookup /etc/dmd.conf");
        - bugItem(11963, "Regression(2.065) ICE(parse.c) Parser crash");
        - bugItem(11965, "Regression(2.064) Segfault on garbage");
        - bugItem(11966, "Regression 2.065.b1: inout(const(char))[] doesn't convert to inout(char)[]");
        - bugItem(11967, "Regression(2.065) ICE(parse.c) Parser crash");
        - bugItem(11980, "startaddress pragma broken (DMD 2.061 regression)");
        - bugItem(11993, "[REG] typeof(this) in constraint of member function template should reflect method qualifier");
        - bugItem(12002, "Internal error: toir.c 181");
        - bugItem(12008, "alias this and \"unable to resolve forward reference\" error");
        - bugItem(12010, "[REG DMD2.065-b1] Undefined template symbols for static library linked with debug symbols");
        - bugItem(12016, "implicit immutable upcast becomes null in CTFE");
        - bugItem(12017, "DDoc leaves out the majority of documentation");
        - bugItem(12023, "Regression 2.065-b2: template mixin fails within template class");
        - bugItem(12037, "Link-failure with std.numeric.CustomFloat");
        - bugItem(12044, "Invalid code gen causes segfault");
        - bugItem(12047, "Regression (2.065 git-head): UDAs are not checked");
        - bugItem(12070, "Variant opCall not static");
        - bugItem(12079, "Internal error: backend/cod4.c 358 for associative array access");
        - bugItem(12080, "Internal error: backend/symbol.c 1035 for invariant");
        - bugItem(12089, "std.utf.validate and inout(char[]) failts to compile");
        - bugItem(12144, "[REG DMD2.064] Unresolved xopEquals when referenced by dynamic array constructor");
        - bugItem(12158, "ICE with .init of nonexisting selective import");
        - bugItem(12160, "UDA related regressions");

    |!= h2(toc, "dmd-compiler-bugs", "DMD Compiler Bugs Fixed")

    ol
        - bugItem(235, "goto & scope: cannot goto forward into different try block level");
        - bugItem(275, "Undefined identifier in instances of templates with forward mixins");
        - bugItem(602, "Compiler allows a goto statement to skip an initalization");
        - bugItem(899, "structure field .offsetof property inaccessible in the scope");
        - bugItem(900, "changing import order causes type mismatch");
        - bugItem(918, "(D1 only): Template order matter, version block change something with typedef, and another template bug.");
        - bugItem(1687, "\"extern (C++) interface\" and vtbl");
        - bugItem(1748, "Wrong stringof for templated classes");
        - bugItem(2481, "mixing field into anonymous struct inside class generates field overlapping vtable");
        - bugItem(2806, "enum member cannot be forward referenced");
        - bugItem(2885, "Silent forward reference bug using ReturnType");
        - bugItem(3013, "Duplicate error message on calling a function with a type");
        - bugItem(3107, "[meta] Property syntax");
        - bugItem(3226, "-fPIC flag doesn't seem to work");
        - bugItem(3279, "(D1 only) Confusing error message when comparing types");
        - bugItem(3307, "Template alias default parameters aren't resolved properly");
        - bugItem(3753, "ICE(eh.c): Related to exception handling and alloca.");
        - bugItem(3817, "Array op: wrong error message");
        - bugItem(3834, "forward reference in templated class");
        - bugItem(3903, "Traits compiles as true for an array sum with wrong syntax");
        - bugItem(3970, "Problem with cast -1.0L ==> uint/ulong");
        - bugItem(3991, "Void initializers in unions considered overlapping");
        - bugItem(4145, "cross alias namespace can't be resolve");
        - bugItem(4162, "pass by alias offset problems");
        - bugItem(4983, "[ICE] Stack overflow while initializing struct member with address of one of its methods");
        - bugItem(5569, "64 bit Dwarf symbolic debug info not recognized by gdb");
        - bugItem(5878, "Forward reference in returning superclass from template using is() expression (Breaks std.traits.BaseTypeTuple)");
        - bugItem(6010, "-fPIC is broken on freebsd/64");
        - bugItem(6382, "edge case with static foreach");
        - bugItem(6439, "[CTFE] union fields are initialized independently");
        - bugItem(6764, "IFTI fails on typesafe variadic function over static array with non IntegerLiteral length");
        - bugItem(6796, "Several __error with wrong enum definition");
        - bugItem(7077, "(D1 only) mixin statements can invade the enclosing scope");
        - bugItem(7175, "Zero-length static array .ptr is always null");
        - bugItem(7472, "Cast from class to basic type not rejected during semantic");
        - bugItem(7645, "ICE(e2ir.c) nested classes");
        - bugItem(7744, "Forward reference in string mixin");
        - bugItem(7966, "First template instantiation inside `with` results in `Error 42: Symbol Undefined`");
        - bugItem(8019, "(D1 only) can't convert [] to int[]");
        - bugItem(8117, "Cannot initialize struct member without default constructor");
        - bugItem(8179, "ICE(e2ir.c) with failed fixed size array cast");
        - bugItem(8200, "DMD segfault: template aliasing result of map");
        - bugItem(8244, "cannot slice a type tuple with '[]' in locations where a type is valid");
        - bugItem(8255, "[CTFE] ICE when passing 'ref' literal");
        - bugItem(8313, "stack overflow on recursive ifti evaluation");
        - bugItem(8365, "Static fixed size array of enums initialization fails");
        - bugItem(8396, "wrong order of evaluation for tuple expansion in function arguments");
        - bugItem(8492, "can't infer type in static assert");
        - bugItem(8511, "Segfault with forward-referenced enum");
        - bugItem(8525, "optimizer loops infinitely");
        - bugItem(8543, "simd literals need better CTFE support");
        - bugItem(8581, "Internal error: backend/cod1.c 1677 on structs with bitfields (when compile with release or optimize parameter)");
        - bugItem(8648, "No error line number with incomplete template");
        - bugItem(8658, "Passing large structs to function b value causes stack corruption");
        - bugItem(8664, "Compiler causes stack overflow with recursive typedef and option -g");
        - bugItem(8711, "ICE with initializing function pointer with array");
        - bugItem(8722, "foreach triggers a floating point exception with multidimensional array of a dimension equal to 0");
        - bugItem(8735, "ICE: Assertion failure: 't' on line 100 in file 'aliasthis.c'");
        - bugItem(8739, "DDoc outputs wrong parameter name in delegate parameter list");
        - bugItem(8825, "Wrong line number of error message");
        - bugItem(8903, "Bad code for enum array members");
        - bugItem(8997, "template instances omit symbol that may be used in other modules");
        - bugItem(9008, "Another forward referencing bug");
        - bugItem(9050, "Too early instantiation of template structs");
        - bugItem(9081, "Modules shouldn't have a type");
        - bugItem(9212, "Associative array foreach iteration with immutable key");
        - bugItem(9256, "A purity-related error message in case of member access");
        - bugItem(9271, "Forwarding lambda predicate with type inference causes segfault");
        - bugItem(9296, "LITTLE_ENDIAN and BIG_ENDIAN are always defined on Linux");
        - bugItem(9301, "using XMM.PSHUFD results in an internal compiler error");
        - bugItem(9356, "-inline with inout and append generates wrong code");
        - bugItem(9459, "Front-end does not detect invalid array operations");
        - bugItem(9466, "Compiler crash with code-coverage generation with large files");
        - bugItem(9504, "typeof does not look up properties correctly on template argument");
        - bugItem(9562, "Built-in runtime properties should become error with `Type.prop`");
        - bugItem(9572, "Missed wrong implicit integral conversion");
        - bugItem(9577, "Crash on static array of function literals");
        - bugItem(9644, "Spell checker gives silly suggestions for 1-2 character symbols");
        - bugItem(9662, "Implement RDMD test suite");
        - bugItem(9690, "cannot access to @disable'd symbol from inner function of another @disable'd");
        - bugItem(9741, "undefined identifier with User Defined Attribute");
        - bugItem(9765, "Error message with __error with struct literal dotvar expression");
        - bugItem(9807, "with statement does not work with alias this");
        - bugItem(9831, "Error message with failed lambda inference");
        - bugItem(9861, "Spurious 'is used as type' error with failed template instantiation");
        - bugItem(9912, "Wrong codegen when using tuple over member variable in more than one method");
        - bugItem(10207, "Alias and @attributes: Assertion failure: '!udas' on line 3132 in file 'parse.c'");
        - bugItem(10224, "core.simd ICE cgcv.c line 2162 when compiling with -g");
        - bugItem(10251, "CTFE: Allow returning pointers to global static variables of known value");
        - bugItem(10259, "ICE on invalid compile-time class instantiation");
        - bugItem(10312, "compiler assert failure with ctfe on simd vector type");
        - bugItem(10313, "inout constructor + IFTI + has indirections arg doesn't work");
        - bugItem(10329, "Attributes not inferred for indirectly templated methods");
        - bugItem(10391, "Segfault compiling on Mac OS 10.8");
        - bugItem(10459, "align(16) does not work on Win64 with seperate compilation");
        - bugItem(10483, "ICE(expression.c) .init of struct with block initialized 2D static array");
        - bugItem(10598, "Using not-imported type - AssertFail: 'global.errors' line 6040 'template.c'");
        - bugItem(10632, "[ICE](glue.c line 1227) With inlining and tuples");
        - bugItem(10635, "Error: cannot use array to initialize S");
        - bugItem(10643, "Refused const array struct field initialized with void");
        - bugItem(10747, "Win64: warning about non-existing vc100.pdb");
        - bugItem(10770, "is(T BASE==enum) with tag enum T - AssertFail:'type' line 428 declaration.c");
        - bugItem(10805, "wrong error message for wrong delimited string");
        - bugItem(10883, "[ICE] Internal error: ../ztc/cod4.c 358 when compiling with -inline");
        - bugItem(10905, "[ICE](ctfeexpr.c line 355) with ulong2 in structs");
        - bugItem(10922, "Compiler segfaults when using __traits(parent, {})");
        - bugItem(10926, "Wrong expression printed when ternary operator used as lvalue");
        - bugItem(10927, "Power of complex number causes an internal error");
        - bugItem(10938, "ICE on recursive instantiation in opDispatch");
        - bugItem(11019, "fwd reference : legal in C++, CT error in D (unable to resolve forward reference in definition)");
        - bugItem(11034, "ICE: Assertion failed: (!scope), function toObjFile, file toobj.c, line 366.");
        - bugItem(11155, "Wrong SIMD code generated (unaligned movaps)");
        - bugItem(11193, "[ICE] String template argument mixed with variadic template arguments causes ICE");
        - bugItem(11198, "Error messages for declaring a 'version' inside main() and other functions are unclear");
        - bugItem(11215, "`inout` lose enclosing `shared` on resolution");
        - bugItem(11224, "Inlining stops NRVO");
        - bugItem(11247, "Error: typeof(i).sizeof is used as a type");
        - bugItem(11286, "Impure dtor makes \"cannot call impure function\" error, although it won't actually be called.");
        - bugItem(11288, "dmd assertion when assigning to (static) opDispatch");
        - bugItem(11297, "[ICE](glue.c line 868) with a string concat in global enum lambda");
        - bugItem(11314, "inline ice with tuple assignment and if/else again");
        - bugItem(11317, "glue.c:1218: virtual unsigned int Type::totym(): Assertion `0' failed.");
        - bugItem(11322, "ICE with -inline cgcs.c 221");
        - bugItem(11332, "ICE(dt.c) and missing error when interpreting an unimplemented builtin");
        - bugItem(11371, "core.simd and ctfe");
        - bugItem(11375, "[profile+nothrow] Semantic 'no throw' error with -profile switch");
        - bugItem(11376, "ICE on __traits(compiles, ...) with invalid array-op");
        - bugItem(11383, "Some array casts incorrectly rejected in safe code");
        - bugItem(11385, "XXX is a nested function and cannot be accessed from XXX");
        - bugItem(11394, "NRVO should work for object field initialization in constructor");
        - bugItem(11406, "ld.gold breaks switch table jumps");
        - bugItem(11425, "Broken shadowing variable diagnostic");
        - bugItem(11427, "anonymous unions break structs in @safe code");
        - bugItem(11445, "adding double[string] causes crash");
        - bugItem(11479, "template members ignore private attribute in ddoc");
        - bugItem(11484, "[e2ir] Error in e2ir at cast to/from static array");
        - bugItem(11485, "[e2ir] Error in e2ir at numeric/bool to class/interface cast");
        - bugItem(11489, "Improper implicit cast to immutable.");
        - bugItem(11497, "lambda in \"static if\"/\"assert\" prevent inlining of function");
        - bugItem(11518, "DMD segfault on multiple template match");
        - bugItem(11534, "[CTFE] inout + returning a pointer into a member array");
        - bugItem(11540, "[ICE] CTFE segfault with try-catch-finally and goto");
        - bugItem(11552, "Missing label is not caught during semantic");
        - bugItem(11562, "Goto into or out of finally block is not caught during semantic");
        - bugItem(11565, "[Optimizer] Zeroes out the higher 32bits of register in ?: expression");
        - bugItem(11587, "Cannot compare AAs at compile time");
        - bugItem(11618, "Internal Compiler Error");
        - bugItem(11627, "[CTFE] cannot cast dchar to char at compile time on AA assignment");
        - bugItem(11629, "[CTFE] crash on AA.rehash");
        - bugItem(11635, "RDMD eats the -op flag when it should just pass through");
        - bugItem(11653, "No error when forgetting break with range cases.");
        - bugItem(11656, "property offsetof does not work with __vector fields");
        - bugItem(11661, "Meaningless error: \"a struct is not a valid initializer for a void function()\"");
        - bugItem(11664, "A function with a local static variable is unusable in CTFE");
        - bugItem(11689, "deprecated local function does not work");
        - bugItem(11696, "C++ incorrect static member mangling");
        - bugItem(11722, "Qualifier-only casts should not invoke opCast");
        - bugItem(11726, "ICE with ufcs on undefined identifier and opDispatch");
        - bugItem(11727, "Repeated error message with using forward referenced enum as variable");
        - bugItem(11735, "pragma(msg, ...) fails to print wstring, dstring");
        - bugItem(11745, "Unittests retrieved by __traits(getUnitTests) can not be invoked if private.");
        - bugItem(11748, "[ICE] function call as alias parameter of template gives ICE");
        - bugItem(11749, "switch case fallthrough error is enabled with -w, but cannot be made informational warning");
        - bugItem(11750, "ICE with debug info and empty #line Filespec");
        - bugItem(11756, "Irrelevant variable name printing in CTFE error message");
        - bugItem(11769, "Wrong line number in \"matches both\" error message");
        - bugItem(11785, "Order of method/function declarations has an effect on compilation result.");
        - bugItem(11790, "ICE(interpret.c): passing creation of array with type string as size to CTFE");
        - bugItem(11793, "[ICE] Compiler runs out of memory with trivial program: class with own class member instance");
        - bugItem(11800, "alias this matching incorrectly changes lvalue-ness");
        - bugItem(11802, "Wrong vtbl order for extern(C++) classes with overloaded functions on win32");
        - bugItem(11813, "Improve IFTI error diagnostic");
        - bugItem(11814, "Unnecessary error messages \"does not match ...\" on IFTI failure");
        - bugItem(11843, "Template instantiated twice: failed semantic analysis");
        - bugItem(11875, "static if template type deduction causes infinite recursion with recursive alias this");
        - bugItem(11926, "Segmentation fault when using const in an enum");
        - bugItem(11944, "ICE(expression.c) Assertion `f' failed.");
        - bugItem(11968, "ICE(expression.c) Crash when deleting __FILE__");
        - bugItem(11969, "ICE(statement.c) When mixing in a array literal containing errors");
        - bugItem(11974, "ICE(cast.c) Segfault with invalid assignment");
        - bugItem(11982, "ICE(func.c) With function literal with no body");
        - bugItem(12038, "alias this and &this cause ICE");
        - bugItem(12040, "Compiler segfault with circular reference in variable type");
        - bugItem(12051, "Wrong code with ?: resulting in char on x86-64");
        - bugItem(12095, "Wrong code with -O -inline");

    |!= h2(toc, "dmd-compiler-enhancements", "DMD Compiler Enhancements")

    ol
        - bugItem(3597, "Need single source for parser and documentation grammar.");
        - bugItem(5109, "some advise");
        - bugItem(5746, "Make std.range.iota strongly pure");
        - bugItem(6930, "combined type of immutable(T) and inout(T) should be inout(const(T))");
        - bugItem(9477, "String (and array) comparisons are needlessly very slow");
        - bugItem(10199, "labels cannot be used without a statement");
        - bugItem(11284, "add -allinst compiler switch");
        - bugItem(11365, "Allow D source file names to have no extension (or an arbitrary extension) when -run is used");
        - bugItem(11417, "rotate with immediate not recognized by optimizer");
        - bugItem(11510, "Relax restriction for overlapped pointer field access in safe code/during CTFE");
        - bugItem(11533, "Compiler should allow to being nested for static local template functions");
        - bugItem(11546, "string import dependency failure");
        - bugItem(11711, "Add __traits(getAliasThis)");
        - bugItem(11759, "Poor error message trying to use lowercase L in literal suffix.");
        - bugItem(11840, "Show all errors of undefined identifier used in a line");

    |!= h2(toc, "phobos-regressions", "Phobos Regressions Fixed")

    ol
        - bugItem(1832, "reading/writing an archive causes data loss; std.zip horribly broken");
        - bugItem(11309, "std.concurrency: OwnerTerminated message doesn't work");
        - bugItem(11512, "Can't build Phobos docs with win32 makefile");
        - bugItem(11527, "JSONValue cannot set values through named fields");
        - bugItem(11528, "appender: crash with -inline -O");
        - bugItem(11576, "std.algorithm.remove!(SwapStrategy.unstable) overruns array bounds");
        - bugItem(11583, "bigint bug");
        - bugItem(11591, "std.typecons.Tuple -s with classes fails at runtime as associative array keys");
        - bugItem(11603, "std.algorithm.canFind does not work when needle is 1-byte zero");
        - bugItem(11671, "ctRegex broken");
        - bugItem(11684, "SIGSEGV with ld.bfd version 2.22");
        - bugItem(11692, "can't set file attributes for std.zip.ArchiveMember");
        - bugItem(11764, "[REG2.065a]std.getopt broken");
        - bugItem(11831, "std.zip no longer allows setting madeVersion field in zip file");
        - bugItem(11838, "Missing emplace import for std.range.zip?");
        - bugItem(11853, "Tuples fail \"isAssignable\"");
        - bugItem(11973, "std/datetime.d(14647): Deprecation: function std.algorithm.canFind!(not).canFind!(immutable(dchar)[]).canFind is deprecated - Please use any instead");
        - bugItem(12024, "[REG DMD2.065-b2] template instantiation for swap(SysTime, SysTime) fails");
        - bugItem(12071, "Algebraic won't take delegate returning structure");
        - bugItem(12098, "libcurl bad argument on handle null");
        - bugItem(12135, "[AA] Format tail after associative array value is treated as separator if explicit separator is empty");
        - bugItem(12168, "[REG2.065a] Add ref to array() and object() of JSONValue getters to add new element");

    |!= h2(toc, "phobos-bugs", "Phobos Bugs Fixed")

    ol
        - bugItem(1804, "Severe GC leaks with repetitive array allocations");
        - bugItem(2162, "Access violation when threads run closures");
        - bugItem(4301, "BigInt * const(BigInt) doesn't work well");
        - bugItem(4673, "Bug in std.string (isNumeric)");
        - bugItem(4874, "std.numeric.dotProduct doesn't work with bigints");
        - bugItem(5280, "to!FP(Hex float string) doesn't work well");
        - bugItem(5762, "getopt: short option parameter read incorrectly when bundling enabled");
        - bugItem(5977, "String splitting with empty separator");
        - bugItem(6730, "std.algorithm.splitter conflicts with std.array.splitter");
        - bugItem(7069, "Variant Doesn't Handle Const or Immutable Contents");
        - bugItem(7689, "splitter() on ivalid UTF-8 sequences");
        - bugItem(8013, "splitter() and split() give different results");
        - bugItem(8203, "Use of std.regex.match() generates \"not enough preallocated memory\" error");
        - bugItem(8291, "dirEntry cannot handle root directories + unhandled exception causes crash");
        - bugItem(8298, "dirEntries special linux file in Home dir");
        - bugItem(8877, "std.encoding.transcode is extremely slow");
        - bugItem(9528, "std.array.appender can't append elements with const members");
        - bugItem(9645, "std.algorithm.splitter on string with char as separator performs badly in certain situations");
        - bugItem(9823, "Delegate accepting element not accepted in std.range.put");
        - bugItem(10569, "std.traits: EnumMembers, isExpressionTuple, isTypeTuple & Largest balks at large input");
        - bugItem(10571, "formattedWrite error with delegate and string");
        - bugItem(10710, "shared phobos library doesn't work on all linux distributions");
        - bugItem(10864, "[REG 2.064][PERFORMANCE] new Safe appender is slower than \"~=\"");
        - bugItem(11005, "std.xml does not encode attributes");
        - bugItem(11110, "Variant.convertsTo doesn't work like isImplicitlyConvertible");
        - bugItem(11112, "Unable to execute shell commands in different threads");
        - bugItem(11148, "Can't implicitly convert const(BigInt) or immutable(BigInt) to BigInt");
        - bugItem(11180, "Launching a process from a Windows GUI process using std.process.spawnProcess always fails");
        - bugItem(11403, "functions in std.algo can't be used as pred");
        - bugItem(11459, "std.container.Array bool constraint ambiguity");
        - bugItem(11568, "can't compile std.stdio.rawWrite with -m64 in Windows");
        - bugItem(11600, "to!BigInt(string) accepts non-numeric input");
        - bugItem(11606, "Cannot instantiate Tuple of non printable");
        - bugItem(11617, "std.uni.normalize doesn't compile");
        - bugItem(11652, "Support numerical ^^ complex operations in std.complex");
        - bugItem(11681, "std.datetime.IntervalRange.opAssign with non-ref parameter is required");
        - bugItem(11691, "can't join pathSplitter with dirSeparator");
        - bugItem(11713, "std.string munch() does not properly handle UTF strings.");
        - bugItem(11738, "partialShuffle actually shuffles the entire input");
        - bugItem(11771, "Unicode set intersection with char is broken");
        - bugItem(11775, "std.regex should check for valid repetition range in assert mode");
        - bugItem(11780, "RangeError in format for incomplete format specifier");
        - bugItem(11808, "std.uni.CodepointSet('А', 'Я'+1, 'а', 'я'+1) asserts");
        - bugItem(11839, "std.regex capture group names should allow numbers to be in them");
        - bugItem(11879, "missing default User-Agent in std.net.curl");
        - bugItem(11884, "std.container.Array lacks a constructor from an input range");
        - bugItem(12069, "ctRegex is 3x slower then R-T ?");

    |!= h2(toc, "phobos-enhancements", "Phobos Enhancements")

    ol
        - bugItem(3868, "It would be nice to have a function which read a file lazily using a range");
        - bugItem(4859, "Another File.byChunk()");
        - bugItem(4909, "Two suggestions for std.algorithm.schwartzSort()");
        - bugItem(5611, "back() and front() with ref return + opSlice() in sort() constraint");
        - bugItem(6986, "SortedRange[x..$] fails with unidentified __dollar");
        - bugItem(8167, "BigInt(BigInt(1)) too");
        - bugItem(9061, "BigInt | BigInt, BigInt & int");
        - bugItem(11770, "std.regex.Captures should be convertible to bool");
        - bugItem(11789, "No setAttributes to complement getAttributes");
        - bugItem(11798, "std.algorithm.all with no predicate too");

    |!= h2(toc, "druntime-regressions", "druntime Regressions Fixed")

    ol
        - bugItem(11478, "shared library on osx: worked in 2.062, fails in 2.063.2, still fails in 2.064");

    |!= h2(toc, "druntime-bugs", "druntime Bugs Fixed")

    ol
        - bugItem(3454, "Inconsistent flag setting in GC.realloc()");
        - bugItem(4809, "Stack trace when throwing exception misses location of the throw statement");
        - bugItem(7508, "float4 values aren't stored on initialisation");
        - bugItem(8301, "Access violation when a big array is allocated");
        - bugItem(10701, "[GC] segfault in GC");
        - bugItem(11806, "Freeze in GC.collect() in in-contracts when multithreading is used");

    |!= h2(toc, "optlink-regressions", "optlink Regressions Fixed")

    ol
        - bugItem(11559, "Optlink crash with more than 2048 modules generated and debug info");

    |!= h2(toc, "optlink-bugs", "optlink Bugs Fixed")

    ol
        - bugItem(2837, "OPTLINK and LARGEADDRESSAWARE");
        - bugItem(3956, "linker removes underscore from all exported symbols of a module but the first");
        - bugItem(6673, "Map file contains broken lines on every 16,384 bytes");
        - bugItem(7634, "optlink creates bad debug info for a large number of modules");

    |!= h2(toc, "installer-bugs", "Installer Bugs Fixed")

    ol
        - bugItem(10246, "Windows installer still downloads from ftp.digitalmars.com");
        - bugItem(11799, "Incompatible argument types in create_dmd_release");

    |!= h2(toc, "installer-enhancements", "Installer Enhancements")

    ol
        - bugItem(10153, "Beta releases should all have unique names");

    |!= h2(toc, "website-regressions", "Website Regressions Fixed")

    ol
        - bugItem(11449, "Jump lists of phobos are in wrong order");

    |!= h2(toc, "website-bugs", "Website Bugs Fixed")

    ol
        - bugItem(5388, "SList.insertFront has complexity O(log(n))");
        - bugItem(9734, "setIntersection accepts only 2 ranges, but documentation says otherwise");
        - bugItem(10205, "'deprecated' '(' assignExpression ')' grammar is not documented");
        - bugItem(10206, "User-defined attributes not documented well in language specification");
        - bugItem(10250, "Grammar does not allow invariants in struct declarations");
        - bugItem(10514, "Constructor declaration grammar is incorrect");
        - bugItem(11398, "Language spec does not allow new eponymous template syntax");
        - bugItem(11579, "dlang.org repo can't be built without git");
        - bugItem(11762, "std.regex macro is not displayed/expanded properly");

    |!= h2(toc, "website-enhancements", "Website Enhancements")

    ol
        - bugItem(11676, "Add a link to D Wiki Sidebar to take users back to DLang.org");
        - bugItem(12087, "Add Readme to dlang.org repository that explains how to contribute");

append extra-sidebar
    |!= toc.write("On This Page")
