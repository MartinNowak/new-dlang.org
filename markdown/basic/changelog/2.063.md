# Change Log &ndash; v2.063

## Language Changes

<h3 id="const-immutable-warn">Const/Immutable Warnings</h3>

Const and immutable fields with initializers are now warned about. Eventually,
they will be deprecated, and then will trigger an error. Such fields should
now be changed to enum or static.

In a future release, a new behavior for them will be enabled:

Fields in an aggregate which are not static will always be addressable.
This means they will occupy space in the object:

```
struct S
{
    // used to be implicitly static in 2.062, now warns.
    // In a future release it will become non-static.
    immutable int[] arr = [1, 2];

    // ditto
    const int[] arr2 = [1, 2];
}
```

This means that code which accessed such declarations without the **this**
reference will no longer compile. Additionally code which depended on the size
of a structure with such fields will have to be fixed:

```
struct S
{
    immutable int[] arr = [1, 2];
}

void main()
{
    // becomes an error in a future release,
    // 'arr' will require the 'this' reference.
    auto x = S.arr;

    // S is size 1 in 2.062 and 2.063.
    // In a future release this will change and the following
    // static assert will pass.

    // ptr + length for the array
    static assert(S.sizeof == size_t.sizeof + size_t.sizeof);
}
```

To make the field static again, simply use the static keyword. Alternatively
make the field an **enum** to turn it into a manifest constant:

```
struct S
{
    static immutable int[] arr = [1, 2];
    enum arr2 = [1, 2];
}
```

Note however that manifest constants which are arrays are allocated on each
usage, so you may prefer using **static** instead.

<h4 id="const-immutable-warn-rationale">Rationale</h4>

Making a field implicitly static based on whether it is const/immutable and has
an initializer leads to confusion. The **static** keyword can be used to
explicitly make any field static.

### Constructor Qualifiers

Constructor qualifiers are taken into account when constructing objects.  A
qualified constructor is now invoked when a **const/immutable/shared**
aggregate object is instantiated, respectively:

```
import std.stdio;

class C
{
    this()           { writeln("1"); }
    this() const     { writeln("2"); }
    this() immutable { writeln("3"); }
    this() shared    { writeln("4"); }
}

void main()
{
    // writes "1"
    auto a = new C;
    // writes "2"
    auto b = new const C;
    // writes "3"
    auto c = new immutable C;
    // writes "4"
    auto d = new shared C;
}
```

This has the consequence that aggregates which have only **immutable** or
**shared** constructors can no longer be used to instantiate mutable objects:

```
class C
{
    this() immutable { }
    this() shared { }
}

void main()
{
    // disallowed
    auto c1 = new C;
    // ok
    auto c2 = new immutable C;
    // ok
    auto c3 = new shared C;
}
```

On the other hand, aggregates which do not have **shared** or **immutable**
constructors can no longer be used to construct **shared** or **immutable**
objects, respectively:

```
class C
{
    this() { }
}

void main()
{
    // ok
    auto c1 = new C;
    // disallowed
    auto c2 = new immutable C;
    // disallowed
    auto c3 = new shared C;
}
```

However, if an aggregate has a **pure** constructor it can be used to construct
an object with any type constructor:

```
class C
{
    this() pure { }
}

void main()
{
    // ok
    auto c1 = new C;
    // ok
    auto c2 = new immutable C;
    // ok
    auto c3 = new shared C;
}
```

### Struct Member Comparison

Struct members which require non-bitwise comparison are now property compared.
In earlier releases some struct members such as arrays would be
bitwise-compared in a comparison operation. This has now been changed to be a
structural comparison instead:

```
struct S
{
    char[] data;
}

void main ()
{
    auto s1 = S("foo".dup);
    auto s2 = S("foo".dup);

    // both are unique data
    assert(s1.data !is s2.data);

    // passes in 2.063
    assert(s1 == s2);
    // equivalent of above
    assert(s1.data == s2.data);
}
```

If an **opEquals** function is not present the compiler rewrites the expression
**s1 == s2** to **s1.tupleof == s2.tupleof**. Comparing **.tupleof**
expressions is also a feature new to D in the 2.063 release.

<h3 id="array-copy-require-slice">Array Copy With Slice Syntax</h3>

Array copy operations now always require using the slice syntax. The
right-hand-side of an array copy operation now requires using the slice syntax:

```
void main()
{
    int[][2] x;
    int[] y;
    int[] z;

    // copies z (pointer + length) 2 times to x
    x[] = z;
    // copies each element of z into y (compiler emits warning)
    y[] = z;
}
```

If the user intended to write such code they must use the slice syntax for both
the source and target arrays:

```
void main()
{
    int[][2] x;
    int[] y;
    int[] z;

    // copies each element of z into y (no warnings)
    y[] = z[];
}
```

<h4 id="array-copy-require-rationale">Rationale</h4>

The compiler will emit a warning to make the user aware that the copy operation
is arbitrarily expensive.

<h3 id="types-typeof">Types in typeof</h3>

Types no longer act as arguments in **typeof** expressions. A type can no
longer be passed to a function as a value of that type

```
T[] foo(T)(T t)
{
    return null;
}

void main()
{
    alias int Int;

    // used to work (only with an alias), now a compiler error
    alias typeof(foo(Int)) IntArray;
}
```

If the user wants to pass an argument of a certain type, they can use the
**.init** property:

```
T[] foo(T)(T t)
{
    return null;
}

void main()
{
    // ok
    alias typeof(foo(int.init)) IntArray;
}
```

<h4 id="types-typeof-rationale">Rationale</h4>

Treating types as expressions in special contexts only leads to confusion.
Instead, the **.init** property can be used for such purposes.

<h3 id="index-variable">foreach Index by Reference</h3>

The index variable in a foreach range is no longer implicitly a reference. It
is now by default a value type:

```
void main()
{
    size_t count;
    foreach (n; 0 .. 10)
    {
        ++n;
        ++count;
    }
    // passes
    assert(count == 10);
}
```

If the user wants to modify the index variable he must use the **ref** keyword:

```
void main()
{
    size_t count;
    foreach (ref n; 0 .. 10)
    {
        ++n;
        ++count;
    }
    assert(count == 5);
}
```

<h4 id="index-variable-rationale">Rationale</h4>

Making the index variable implicitly **ref** can introduce bugs that are hard
to track down.

<h3 id="aa-no-default-init">AA Default Initilization</h3>

Associative array entries are no longer default-initialized before assignment.
This used to be the case:

```
void main()
{
    int[int] aa;
    // no Error thrown in 2.062
    aa[1] = aa[1] + 1;
    // worked in 2.062
    assert(aa[1] == 1);
}
```

In 2.063, accessing an entry which does not exist will now throw a RangeError:

```
void main()
{
    int[int] aa;
    // RangeError thrown in 2.063
    aa[1] = aa[1] + 1;
}
```

<h4 id="aa-no-default-init-rationale">Rationale</h4>

Default-initialization during assignment can be a source of bugs.

<h3 id="const-attribute-inherited">const Inheritance</h3>

Method overrides no longer inherit constness of the base method:

```
class A
{
    void foo() const { }
}

class B : A
{
    // used to work in 2.062, now an error
    // note missing 'const' on the end.
    override void foo() { }
}
```

If the user wants to override a const method he has to mark the overriden
method as const:

```
class A
{
    void foo() const { }
}

class B : A
{
    // ok, trailing const is used.
    override void foo() const { }
}
```

The feature allows introducing new overloads based on the constness of the
method:

```
class A
{
    void foo() const { }
}

class B : A
{
    // introduces new overload (not override!)
    void foo() { }

    // if the above overload is introduced the user must either:
    // a: re-introduce the const overload
    //    to prevent function hijacking

    // without this you will get a compiler error
    alias super.foo foo;

    // or b: provide a properly typed override:
    override void foo() const { }
}
```

<h3 id="typeof-null">typeof(null) and Slices</h3>

```typeof(null)``` no longer implicitly converts to ```T[]```. The following
code used to be allowed:

```
void f(int[] function() del)
{
    // fails
    assert(!del());
}

typeof(null) g() { return null; }

void main()
{
    f(&amp;g);
    f(() => null);
}
```

However the implicit conversion would end up generating wrong code.
To work around this, make sure the return type is typed properly,
or use (T[]).init in the return expression of a lambda expression:

```
void f(int[] function() del)
{
    // passes
    assert(!del());
}

// fixed return type
int[] g() { return null; }

void main()
{
    // ok
    f(&g);
    // ok
    f(() => (int[]).init);
}
```

<h3 id="template-this-parameter">Template this Parameter</h3>

The [Template this Parameter](/template#TemplateThisParameter) can now be used
to infer the qualifier of **this** to member functions:

```
struct S
{
    void foo(this T)()
    {
    }
}

void main()
{
     immutable S s;
     // makes S.foo immutable
     s.foo();
}
```

<h3 id="array-slice-rvalues">Array Slice r-values</h3>

Array slices are no longer l-values. This means an address can no longer be
taken of a slice, and slices cannot be passed by ref to functions:

```
void foo(ref int[] arr) { arr = new int[10]; }

void main()
{
    int[] arr;
    // ok
    foo(arr);
    assert(arr.length == 10);

    // disallowed in 2.063, the slice is an r-value
    foo(arr[]);
    // disallowed in 2.063, cannot take address of r-value
    auto ptr = &amp;arr[1..2];
}
```

To work around this you can make your function take an r-value if it doesn't
need to reassign and resize the slice, but only needs to read or modify its
contents. Otherwise, to accept both l-values and r-values you can make your
function take its argument by **auto ref**:

```
void take(int[] arr) { }
void takeRef(ref int[] arr) { }
void takeAutoRef(T)(auto ref T[] arr) { }

void main()
{
    int[] arr = [1, 2, 3, 4];
    // ok
    take(arr);
    // ok
    takeRef(arr);
    // ok
    takeAutoRef(arr);

    int[] arr2 = arr[1 .. 2];
    // ok, arr2 is a variable
    take(arr2);
    // ditto
    takeRef(arr2);
    // ditto
    takeAutoRef(arr2);

    // ok
    take(arr[1 .. 2]);
    // error, cannot pass r-value by reference
    takeRef(arr[1 .. 2]);
    // ok
    takeAutoRef(arr[1 .. 2]);
}
```

<h4 id="array-slice-rvalues-rationale">Rationale</h4>

Passing slices by reference had no observable effect when reassigning or
resizing such a slice at the call site, therefore such slices should by default
be r-values. For example, the following code used to be allowed but is now
a compile-time error:

```
void reAssign(ref int[] arr) { arr = new int[2]; }
void reSize(ref int[] arr)   { arr.length = 10; }

void main()
{
    int[] arr = [1, 2, 3, 4];

    // reassigning has no observable effect at the call site
    reAssign(arr[0 .. 4]);
    assert(arr == [1, 2, 3, 4]);

    // resizing has no observable effect at the call site
    reSize(arr[0 .. 4]);
    assert(arr.length == 4);
}
```

<h3 id="non-static-this">Non-static 'this'</h3>

Accessing a non-static field without a ```this``` reference is now only allowed
in certain contexts.  Accessing non-static fields used to be allowed in many
contexts, but is now limited to only a few:

**offsetof**, **init**, and other built-in properties are allowed:

```
struct S { int field; }

void main()
{
    // ok, statically known
    auto a = S.field.offsetof;
    // ditto
    auto c = S.field.max;
    // disallowed, no `this` reference
    auto d = S.field;
}
```

When invoking static methods of a non-static field:

```
struct Foo
{
    static struct Bar
    {
        static int get() { return 0; }
    }

    Bar bar;
}

void main()
{
    // ok, equivalent to `typeof(Foo.bar).get()'
    static assert(Foo.bar.get() == 0);
}
```

When accessing static fields implicitly using an [alias this](/class#AliasThis)
expression:

```
struct Foo
{
    static struct Bar
    {
        static int get() { return 0; }
    }

    Bar bar;
    alias bar this;
}

void main()
{
    // ok, equivalent to 'typeof(Foo.bar).get()'
    static assert(Foo.get() == 0);
}
```

<h3 id="array-implicit-pointer">Arrays & Pointers</h3>

Arrays no longer implicitly convert to a pointer. The implicit conversion of an
array to a pointer was a deprecated feature:

```
void foo(int* p) { }

void main()
{
    int[] arr = [1, 2];
    // ok if -d switch is used during compilation
    foo(arr);
}
```

This feature has now been completely removed. The workaround is to either use
the **.ptr** property, or explicitly pass the pointer to the first element:

```
void foo(int* p) { }

void main()
{
    int[] arr = [1, 2];
    // compile time error
    foo(arr);
    // ok
    foo(arr.ptr);
    // ok
    foo(&arr[0]);
}
```

<h2 id="language-enhancements">Language Enhancements</h2>

<h3 id="unique-immutable">Unique and Immutable</h3>

Expressions which return unique objects can be implicitly casted to
**immutable**.

Expressions such as **new** for objects and arrays, and **dup** for arrays, can
now be inferred to be unique. This allows the compiler to implicitly convert
such an expression to immutable:

```
class C { }

void main()
{
    // ok
    immutable int[] arr1 = new int[](3);
    // ok in 2.063
    immutable int[] arr2 = [1, 2, 3].dup;
    // ok in 2.063
    immutable C[] arr3 = [new C, new C].dup;
}
```

<h3 id="array-void-init">Initializing Void Static Arrays</h3>

A static array of void could not be initialized in user-code:

```
void main()
{
    // error in 2.062
    void[2] varr1;
    // error in 2.062
    void[2] varr2 = (void[2]).init;
    // ok in 2.062
    void[2] varr3 = void;
}
```

In 2.063, an explicit initializer can be used:

```
void main()
{
    // still an error in 2.063
    void[2] varr1;
    // ok in 2.063
    void[2] varr2 = (void[2]).init;
    // ok in 2.063
    void[2] varr3 = void;
}
```

The **.init** property effectively zero-initializes the array.

<h4 id="array-void-init-rationale">Rationale</h4>

The restriction has been lifted to allow generic code to use **.init** without
having to specialize for static void arrays.

<h3 id="aggregate-multiple-invariant">Multiple Invariants</h3>

If an aggregate type has multiple invariants, the invariants' bodies will be
merged into a single invariant function and will be run in sequence. Note that
the code in one invariant cannot reference code or data in another invariant:

```
struct S
{
    int x;

    void foo() { }

    invariant()
    {
        int local;
        assert(x != 0);
    }

    invariant()
    {
        // invariant does not have access to the body
        // of the other invariant.

        // local = 1;
        assert(x % 2 == 0);
    }
}

void main()
{
    S s = S(2);
    // invoking public function triggers both invariants
    // in sequence
    s.foo();
}
```

<h3 id="is-exprsesion-identifiers">'is' Expression Identifiers</h3>

In some cases the [is expression](/expression#IsExpression) required an
identifier even when you didn't have a use for it:

```
void main()
{
    alias AA = string[int];

    static if (is(AA _ == V[K], V, K))
    {
        // prints string[int]
        pragma(msg, _);
        // prints int
        pragma(msg, K);
        // prints string
        pragma(msg, V);
    }
}
```

The identifier is no longer required, so the above can be rewritten to:

```
void main()
{
    alias AA = string[int];

    static if (is(AA == V[K], V, K))
    {
        // prints string[int]
        pragma(msg, AA);
        // prints int
        pragma(msg, K);
        // prints string
        pragma(msg, V);
    }
}
```

<h3 id="dynamic-to-static">Dynamic to Static Arrays</h3>

Dynamic arrays of known size can be implicitly cast to static arrays in some
contexts. In some contexts the compiler knows the size of a dynamic array or
of a slice of an array. In such a case the compiler will allow an implicit
conversion to a static array of the same size:

```
void foo(int[4] x) { }

void main()
{
    int[] arr = [1, 2, 3, 4, 5, 6, 7, 8];
    // ok
    foo(arr[0 .. 4]);
}
```

Another example, where a string is converted to a reference to a static array:

```
string str = "aaaabbbbccccdddd";

void foo(ref const(char)[16] buf)
{
    assert(buf.ptr is str.ptr);
}

void main()
{
    // ok
    foo(str[0..16]);
}
```

<h4 id="dynamic-to-static-limitations">Limitations</h4>

This feature does not yet work with complex expressions where it might be
reasonable to assume the size of a slice:

```
void foo(int[4] x) { }

void main()
{
    int[] arr = [1, 2, 3, 4, 5, 6, 7, 8];
    foreach (i; 0 .. 4)
    {
        // not yet supported
        foo(arr[i .. i + 4]);
    }
}
```

<h3 id="tuple-void-initialization">Tuple Void Initialization</h3>

You can now void-initialize a tuple variable:

```
template Tuple(T...)
{
    alias T Tuple;
}

void main()
{
    // ok
    Tuple!(int, int) tup1 = void;
}
```

Upon such initialization the values in the tuple are undetermined.

<h3 id="template-constraints-inheritance">Template Constraints and Inheritance</h3>

Template constraints can now be put after the inheritance list.

Template constraints used to be allowed only before the inheritance list,
leading to code where the inheritance list could be hard to spot:

```
class Foo(T1, T2)
if (is(T1 == int) && is(T2 == string)) : Base
{
}
```

This restriction has been lifted, so you can now write:

```
class Foo(T1, T2) : Base
if (is(T1 == int) && is(T2 == string))
{
}
```

<h3 id="tuple-equality">Tuples and Equality</h3>

Tuples can now be compared for equality:

```
struct Tuple(T...) { T field; alias field this; }

void main()
{
    auto tup1 = Tuple!(int, int)(1, 2);
    auto tup2 = Tuple!(int, int)(1, 2);
    auto tup3 = Tuple!(int, int)(1, 3);

    // works since 2.063
    assert(tup1 == tup2);
    // works since 2.063
    assert(tup1 != tup3);
}
```

This also means you can now compare **ParameterStorageClassTuple** instances
from std.traits:

```
import std.traits;

void func1(ref int x, ref int y) { }
void func2(ref float x, ref float y) { }

void main()
{
    alias Storages = ParameterStorageClassTuple;
    assert(Storages!func1 == Storages!func2);
}
```

In addition to that, builtin **.tupleof** expressions can be used to easily
compare fields of an aggregate:

```
struct S
{
    char[] a, b;

    // Implements an equality test
    // against another instance of this type.
    bool opEquals(S rhs) {
        return this.tupleof == rhs.tupleof;
    }
}

void main()
{
    S s1 = S("a".dup, "b".dup);
    S s2 = S("a".dup, "b".dup);
    assert(s1 == s2);
}
```

This also allows you to implement a structural equality test against an
instance of a different type:

```
struct S1
{
    char[] a, b;

    // Implements a structural equality test
    // against any other type T
    bool opEquals(T)(T rhs) {
        return this.tupleof == rhs.tupleof;
    }
}

struct S2
{
    string x, y;
}

void main()
{
    auto s1 = S1("123".dup, "456".dup);
    auto s2 = S2("123", "456");
    assert(s1 == s2);
}
```

Since tuples can be sliced you can use this feature to compare a subset of
tuples:

```
struct S
{
    int a, b, c, d, e;

    bool opEquals(S rhs)
    {
        // compares a, b, d, and e
        return this.tupleof[0..2] == rhs.tupleof[0..2] &&
               this.tupleof[3..5] == rhs.tupleof[3..5];
    }
}

void main()
{
    S s1 = S(1, 2, 0, 3, 4);
    S s2 = S(1, 2, 1, 3, 4);
    assert(s1 == s2);
}
```

<h3 id="reinit-const-fields">Reinitializing Const Fields</h3>

You can now initialize a field in a const constructor even if such
a field already has an initializer:

```
struct S
{
    bool field = true;

    this(int v) const
    {
        // ok
        field = false;
    }
}
```

<h3 id="isnested-trait">isNested Trait</h3>

A new trait, [isNested](/traits#isNested) has been added for discovery of
aggregates and functions with context pointers:

```
void main()
{
    int x;

    struct S1 { void f() { x++; } }
    static struct S2 { }

    void f1() { x++; }
    static void f2() { }

    static assert(__traits(isNested, S1));
    static assert(__traits(isNested, f1));
    static assert(!__traits(isNested, S2));
}
```

<h3 id="templates-inside-functions">Templates Inside Functions</h3>

Templates can now be nested inside of functions:

```
void test()
{
    template ArrayOf(T) { alias ArrayOf = T[]; }
    static assert(is(ArrayOf!int == int[]));
}
```

Allowing **template**s inside of functions will enable better encapsulation and
avoid the pollution of module-scoped symbol names.

<h3 id="scoped-local-ufcs">Scoped Local UFCS</h3>

Functions that are made available through a local import are now picked up when
using Uniform Function Call Syntax:

```
module foo;
string concat(string arg1, string arg2) { return arg1 ~ arg2; }
```

```
module test;
void main()
{
    import foo;
    // UFCS now works
    assert("foo".concat("bar") == "foobar");
}
```

This feature also works for imports within aggregates. Note that local imports
have a higher precedence than module-scoped imports.

<h3 id="new-special-keywords">New Special Keywords</h3>

A new set of [special keywords](/traits#specialkeywords) were added:
**__FUNCTION__**, **__PRETTY_FUNCTION__** and **__MODULE__**: Together
with **__FILE__** and **__LINE__** they form a complete feature set that
is useful in debugging code:

```
module test;
import std.stdio;

void test(string file = __FILE__, size_t line = __LINE__,
string mod = __MODULE__, string func = __FUNCTION__,
string pretty = __PRETTY_FUNCTION__)
{
    writefln(
        "file: '%s', line: '%s', module: '%s',\\n"
        ~ "function: '%s',\\n"
        ~ "pretty function: '%s'",
        file, line, mod, func, pretty
    );
}

int main(string[] args)
{
    test();
    return 0;
}
```

The above will output:

```
file: 'test.d', line: '13', module: 'test',
function: 'test.main',
pretty function: 'int test.main(string[] args)'
```

### DDoc DEPRECATED Macro

Deprecated declarations in DDoc are now wrapped in a DEPRECATED macro:

```
module test;

/// sum function
deprecated int sum(int x, int y) { return x + y; }
```

By default the macro expands to its argument. It can be overriden by the user,
for example:

**macros.ddoc:**

```
DEPRECATED=<del>$0</del>
```

The above ddoc file can then be used when the documentation is being generated:

### Documenting Unit Tests

Documented **unittest** blockss which follow any symbol declarations are now
used to generate example sections for the symbol when generating DDOC
documentation. Example:

```
/// sum function
int sum(int x, int y) { return x + y; }

///
unittest
{
    assert(sum(2, 2) == 4);
}
```

The body of the unittest will be part of the documentation of the sum function.
This allows the implementor of the function to keep their examples always
up-to-date.

For more information, see the
[documentation page](/unittest#documented-unittests)
of documented unittests.

## Compiler Enhancements

<h3 id="main-switch">-main Switch</h3>

A **-main** switch which adds an empty main function. The **-main** switch is
primarily useful when unittesting libraries:

```
module test;

int sum(int a, int b) { return a + b; }
unittest
{
    assert(sum(2, 2) == 4);
}
```

The above library would need a **main()** function for the unittests to run,
and **-main** can be used for this purpose:

```
$ dmd -unittest -main -run test.d
```

<h3 id="cov-switch">-cov Switch</h3>

The **-cov** switch now has an optional percentage setting which makes the
executable emit an error when the coverage doesn't meet the specified
requirement:

```
module test;

void test1() { int x = 5; }
void test2() { int x = 5; }
void test3() { int x = 5; }

void main()
{
    test1();
    test2();
}
```

Example of coverage testing:

```
$ dmd -cov=90 test.d
$ test
Error: test.d is 80% covered, less than required 90%
```

### Overriding Mangling

The new **pragma(mangle, ...)** directive allows you to set a custom mangling
for any symbol:

```
pragma(mangle, "module") extern(C) void module_();
```

The above allows linking to a C function named "module", which ordinarily we
wouldn't be able to link to directly since "module" is a reserved D keyword.

## Phobos Changes

<h3 id="std-typecons-scoped">std.typecons.scoped</h3>

std.typecons.scoped implementation changed, potentially breaking some
user-code:

User-code which used the **std.traits.ReturnType** trait to retrieve the type
of a **scoped** call will have to be changed to use the **typeof** operator
instead:

```
class A
{
    this() {}
    this(int) {}
}

class B
{
    // disallowed in 2.063
    // ReturnType!(scoped!A) a;

    // rewritten, compiles in 2.063
    typeof(scoped!A()) a;

    this()
    {
        // would not compile in 2.062,
        // but works with syntax used for 2.063
        a = scoped!A(1);
    }
}
```

The reason for this change is that the **ReturnType** trait would retrieve the
wrong type when a class had multiple constructors, and this would cause
initializing the field to fail.

Another benefit of the new implementation is that **scoped** can now be aliased
for usability purposes:

```
class A
{
    this(int) { }
}

void main()
{
    alias scoped!A scopeA;
    auto a = scopeA(1);
}
```

## Phobos Enchancements

<h3 id="std-process-redesigned">std.process Redesigned</h3>

[std.process](/phobos/std_process) has been redesigned from the ground up and
introduces a new API and functionality:

The new [std.process](/phobos/std_process) module introduces functionality for
invoking processes with custom pipe redirection, the ability to wait for
processes to finish, and the ability to kill processes. The full list of
features can be found in the [std.process](/phobos/std_process) documentation.

<h3 id="std-getopt-false-booleans">std.getopt false Booleans</h3>

std.getopt can now set booleans to false:

```
void main(string[] args)
{
    bool flag = true;
    getopt(args, &flag);
}
```

When invoked via **--flag=false**, it will set **flag** to **false**.

<h3 id="std-concurrency-ownertid">std.concurrency ownerTid</h3>

It is now easier to send a message from a child thread to its owner thread.
Simply use the **ownerTid** property to get the owner thread's Tid identifier:

```
void fun()
{
    string res = receiveOnly!string();
    assert(res == "Main calling");

    // new
    ownerTid.send("Child responding");
}

void main()
{
    auto child = spawn(&fun);
    child.send("Main calling");

    string res = receiveOnly!string();
    assert(res == "Child responding");
}
```

If the owner thread has exited, accessing **ownerTid** from any of its child
threads will throw a **TidMissingException**.

## DMD Compiler Regressions Fixed

* [Bugzilla 9130](/bug/9130) &mdash; Wrong codegen for compile time constructed struct
* [Bugzilla 9258](/bug/9258) &mdash; opAssign with base class triggers "identity assignment operator overload" error
* [Bugzilla 9526](/bug/9526) &mdash; ICE when compiling project with unittests
* [Bugzilla 9536](/bug/9536) &mdash; IFTI fails when calling a static member from const member
* [Bugzilla 9538](/bug/9538) &mdash; Regression (2.062): Can't use typeid on .ptr of static array
* [Bugzilla 9539](/bug/9539) &mdash; Wrong implicit conversion of array to pointer
* [Bugzilla 9545](/bug/9545) &mdash; [REG 2.063a] ICE with member template instantiation
* [Bugzilla 9552](/bug/9552) &mdash; DMD crashed when taking member delegate from __traits(getOverloads)
* [Bugzilla 9566](/bug/9566) &mdash; Regression (2.062): Cannot use struct .init when it contains a static array initialized from a single element.
* [Bugzilla 9568](/bug/9568) &mdash; [64bit] wrong code for scope(exit)
* [Bugzilla 9633](/bug/9633) &mdash; compiles trait wrongly returns true even when object method call actually does not compile
* [Bugzilla 9650](/bug/9650) &mdash; __traits(compiles) + mixin
* [Bugzilla 9663](/bug/9663) &mdash; [REG2.063a] ICE caused by issue 7444 change.
* [Bugzilla 9672](/bug/9672) &mdash; mixin within cyclic import causes undefined properties
* [Bugzilla 9689](/bug/9689) &mdash; std.typecons.Proxy breaks with @disable this(this)
* [Bugzilla 9694](/bug/9694) &mdash; A member struct that has mutable opEquals reports weird error message
* [Bugzilla 9739](/bug/9739) &mdash; Regression (1.077 git-head): DMD not considering ctor with default args as default ctor
* [Bugzilla 9759](/bug/9759) &mdash; compiler segfault in StructLiteral::implicitConvTo(Type*) on invalid code
* [Bugzilla 9764](/bug/9764) &mdash; Ddoc: Ddoc file name is incorrectly emphasized
* [Bugzilla 9775](/bug/9775) &mdash; Can no longer create a const Date in CTFE if the variable is explicitly typed
* [Bugzilla 9806](/bug/9806) &mdash; assertion failure in struct.c:668
* [Bugzilla 9834](/bug/9834) &mdash; incorrect detection of lambda locality.
* [Bugzilla 9846](/bug/9846) &mdash; regression of forward references
* [Bugzilla 9858](/bug/9858) &mdash; const alias this fails when opAssign is present
* [Bugzilla 9865](/bug/9865) &mdash; Crash on bogus import / circular reference
* [Bugzilla 9890](/bug/9890) &mdash; Alias This + Alias Fields
* [Bugzilla 9903](/bug/9903) &mdash; Broken ddoc in std.typecons and etc.c.sqlite3
* [Bugzilla 9919](/bug/9919) &mdash; Regression (2.062): Symbol lookup fails with public import and mixin
* [Bugzilla 9952](/bug/9952) &mdash; regression(HEAD): Attribute inference for virtual functions breaks subclasses
* [Bugzilla 9957](/bug/9957) &mdash; [2.061 -> 2.062] Taking pointer of enum float array gives some garbage
* [Bugzilla 9974](/bug/9974) &mdash; immutable class constructor is broken
* [Bugzilla 9984](/bug/9984) &mdash; inout qualifier is skipped for constructor arguments (template constructor only)
* [Bugzilla 9987](/bug/9987) &mdash; Declaring struct ModuleInfo should be allowed
* [Bugzilla 10002](/bug/10002) &mdash; 2.062 -> 2.063 calling "remove" is impure
* [Bugzilla 10003](/bug/10003) &mdash; void* UFCS regression
* [Bugzilla 10016](/bug/10016) &mdash; Incorrect error gagging using RefCounted
* [Bugzilla 10040](/bug/10040) &mdash; struct-related ICE
* [Bugzilla 10041](/bug/10041) &mdash; ufcs writeln of associative array
* [Bugzilla 10043](/bug/10043) &mdash; ICE with __traits(compiles)
* [Bugzilla 10044](/bug/10044) &mdash; Wrong di generation for IsExp with TemplateParameterList
* [Bugzilla 10047](/bug/10047) &mdash; opDispatch instantiation failure should be gagged for UFCS
* [Bugzilla 10049](/bug/10049) &mdash; Spurious "Label already defined" error inside a foreach over a range aggregate
* [Bugzilla 10050](/bug/10050) &mdash; Regression (git-head): RDMD no longer emits error messages from DMD
* [Bugzilla 10053](/bug/10053) &mdash; struct member with pure dtor forces declared dtor to be pure, too
* [Bugzilla 10055](/bug/10055) &mdash; Incorrect attribute merging in dtor/postblit building
* [Bugzilla 10056](/bug/10056) &mdash; Strange Error with templates and string.format
* [Bugzilla 10067](/bug/10067) &mdash; [REG] Recursive template instantiation
* [Bugzilla 10073](/bug/10073) &mdash; Default opEquals depends on class declaration order with DMD HEAD
* [Bugzilla 10076](/bug/10076) &mdash; expression.c:4310: virtual Expression* TypeExp::semantic(Scope*): Assertion `0' failed.
* [Bugzilla 10089](/bug/10089) &mdash; Strange function call error message with specified module
* [Bugzilla 10091](/bug/10091) &mdash; [HEAD] Cannot cast struct member string enum to static ubyte array of same size
* [Bugzilla 10096](/bug/10096) &mdash; Regression (git-head): __traits(allMembers) triggers out of bounds error
* [Bugzilla 10101](/bug/10101) &mdash; static if conditional cannot be at global scope using mixin template
* [Bugzilla 10106](/bug/10106) &mdash; [ICE] Ice in glue.c:1215 + 2 error messages without lines
* [Bugzilla 10134](/bug/10134) &mdash; Mutual referencing templates error
* [Bugzilla 10142](/bug/10142) &mdash; [REG2.063a] enum value semantic problem that declared in class member
* [Bugzilla 10144](/bug/10144) &mdash; Using enum inside final class occurs weird errors
* [Bugzilla 10148](/bug/10148) &mdash; regression 062=>063: unjustified 'safe function cannot call system function'
* [Bugzilla 10151](/bug/10151) &mdash; final: before enum is now an error.
* [Bugzilla 10160](/bug/10160) &mdash; No line number "cannot modify struct ... with immutable members"
* [Bugzilla 10166](/bug/10166) &mdash; XXX is not a template
* [Bugzilla 10178](/bug/10178) &mdash; Compiler segfault with zero-length tuple comparison

## DMD Compiler Bugs Fixed

* [Bugzilla 1520](/bug/1520) &mdash; TypeInfo_Const.opEquals is incorrect
* [Bugzilla 1804](/bug/1804) &mdash; Severe GC leaks with repetitive array allocations
* [Bugzilla 2356](/bug/2356) &mdash; array literal as non static initializer generates horribly inefficient code.
* [Bugzilla 3789](/bug/3789) &mdash; [TDPL] Structs members that require non-bitwise comparison not correctly compared
* [Bugzilla 4094](/bug/4094) &mdash; ICE(expression.c): recursive struct templates with type inference
* [Bugzilla 4247](/bug/4247) &mdash; Cannot create default-constructed struct on heap when constructor is defined
* [Bugzilla 4414](/bug/4414) &mdash; ICE(cgcs.c) Taking item of static array returned by function
* [Bugzilla 4436](/bug/4436) &mdash; Double bug regarding Tuple.init
* [Bugzilla 4479](/bug/4479) &mdash; Module Foo is in multiple files Foo
* [Bugzilla 4617](/bug/4617) &mdash; Alias this'ed symbols cannot be passed to templates
* [Bugzilla 4814](/bug/4814) &mdash; rdmd: Doesn't rebuild when using -of and turning an -L linker option on or off
* [Bugzilla 5450](/bug/5450) &mdash; no match for implicit super() call in constructor
* [Bugzilla 5625](/bug/5625) &mdash; std.format unittest disabled
* [Bugzilla 6070](/bug/6070) &mdash; CTFE UFCS forward reference error
* [Bugzilla 6089](/bug/6089) &mdash; __gshared with not static 2D array
* [Bugzilla 6153](/bug/6153) &mdash; Inserting to An Array!T inside an Array!(Array!T) causes a segfault.
* [Bugzilla 6312](/bug/6312) &mdash; template instance cannot use argument from enclosing template
* [Bugzilla 6431](/bug/6431) &mdash; [RDMD] Modifying a library doesn't trigger a rebuild
* [Bugzilla 6535](/bug/6535) &mdash; RDMD outputs broken library files
* [Bugzilla 6539](/bug/6539) &mdash; Incomprehensible error message with failed template instantiation
* [Bugzilla 6545](/bug/6545) &mdash; [CTFE] Hard-coded array operations not yet supported
* [Bugzilla 6578](/bug/6578) &mdash; Ignored const with struct with constructor
* [Bugzilla 6795](/bug/6795) &mdash; ICE(cgcs.c): Incrementing an enum array item
* [Bugzilla 6852](/bug/6852) &mdash; Cannot compare instances of ParameterStorageClassTuple
* [Bugzilla 7068](/bug/7068) &mdash; copying array of pointers calls memset instead of memcpy with -d
* [Bugzilla 7437](/bug/7437) &mdash; DMD enters infinite loop during overload resolution
* [Bugzilla 7569](/bug/7569) &mdash; cannot void initialize tuple declarations
* [Bugzilla 7572](/bug/7572) &mdash; f.fn!(void) is not an lvalue
* [Bugzilla 7719](/bug/7719) &mdash; enum forward reference error when enum is in braces
* [Bugzilla 7980](/bug/7980) &mdash; Stack overflow / recursive expansion with alias this
* [Bugzilla 8041](/bug/8041) &mdash; __gshared/static problem
* [Bugzilla 8081](/bug/8081) &mdash; pure nothrow unittest problem in generated 'header' file
* [Bugzilla 8130](/bug/8130) &mdash; Memory corruption because without *.def file DMD compiles DLL with assumption `_tls_index = 0`
* [Bugzilla 8213](/bug/8213) &mdash; Incorrect error message with pointer to ubyte[] and front
* [Bugzilla 8238](/bug/8238) &mdash; templates can create ghost fields
* [Bugzilla 8245](/bug/8245) &mdash; UFCS doesn't work for pointers
* [Bugzilla 8294](/bug/8294) &mdash; complex breaks calling in 64 bit DMD
* [Bugzilla 8347](/bug/8347) &mdash; Parser bug with const placed after ~this() in decl
* [Bugzilla 8366](/bug/8366) &mdash; Overriding const member function in conjunction with mutable overload causes a strange error
* [Bugzilla 8589](/bug/8589) &mdash; Incorrect conversion of function returning `typeof(null)` to function returning an array
* [Bugzilla 8609](/bug/8609) &mdash; A forward reference error with static arrays
* [Bugzilla 8668](/bug/8668) &mdash; public selective import makes functions conflict when otherwise they don't
* [Bugzilla 8670](/bug/8670) &mdash; IFTI fails from aliases
* [Bugzilla 8697](/bug/8697) &mdash; Invalid error message: Forward reference of interface
* [Bugzilla 8698](/bug/8698) &mdash; Forward reference error with interfaces
* [Bugzilla 8827](/bug/8827) &mdash; Cannot move contents of R12
* [Bugzilla 8828](/bug/8828) &mdash; Long compilation time of a destroy() on a large fixed-sized matrix
* [Bugzilla 8833](/bug/8833) &mdash; Odd error with expression tuples
* [Bugzilla 8902](/bug/8902) &mdash; Unexpected "duplicate union initialization for X" error
* [Bugzilla 8945](/bug/8945) &mdash; Can't call static struct initializer or constructor without qualifier for templated inner struct
* [Bugzilla 8953](/bug/8953) &mdash; Parser rejects qualifier after destructor i.e. `~this() { }`
* [Bugzilla 8989](/bug/8989) &mdash; cfloat argument passing broken
* [Bugzilla 8998](/bug/8998) &mdash; 'inout pure' returns immutable, which in reality is mutable
* [Bugzilla 9091](/bug/9091) &mdash; Using __traits(getMember) on template argument fails inside member function
* [Bugzilla 9144](/bug/9144) &mdash; synchronized CRITSECSIZE should be a target constant
* [Bugzilla 9199](/bug/9199) &mdash; Module level qualified functions should be rejected
* [Bugzilla 9209](/bug/9209) &mdash; ice(symbol.c) with const struct heap allocation
* [Bugzilla 9231](/bug/9231) &mdash; overriding inout funcion with attribute inference reports weird error
* [Bugzilla 9232](/bug/9232) &mdash; Parsing error on some templated methods calls
* [Bugzilla 9241](/bug/9241) &mdash; 2.061: Property call error message disappeared
* [Bugzilla 9280](/bug/9280) &mdash; Runtime range violation with named capture groups in regex
* [Bugzilla 9311](/bug/9311) &mdash; shared library file extension incorrectly modified
* [Bugzilla 9345](/bug/9345) &mdash; CTFE fails when using std.string.format with imported string enum
* [Bugzilla 9346](/bug/9346) &mdash; nested struct calls disabled postblit
* [Bugzilla 9386](/bug/9386) &mdash; struct destructor called erroneously
* [Bugzilla 9393](/bug/9393) &mdash; Partial template specialization and template lambda does not work
* [Bugzilla 9401](/bug/9401) &mdash; destructor and nothrow syntax
* [Bugzilla 9413](/bug/9413) &mdash; Incorrect modification inside contracts is not detected correctly
* [Bugzilla 9414](/bug/9414) &mdash; Incorrect modification inside contracts is not detected on virtual function
* [Bugzilla 9415](/bug/9415) &mdash; delegate inference should make function literal impure
* [Bugzilla 9417](/bug/9417) &mdash; "no size yet for forward reference" error with nested structure
* [Bugzilla 9428](/bug/9428) &mdash; Wrong array concatenation
* [Bugzilla 9441](/bug/9441) &mdash; struct constructor missed on auto/type-inferred variable definition
* [Bugzilla 9445](/bug/9445) &mdash; interpret.c:151: Assertion `v->ctfeAdrOnStack >= 0 && v->ctfeAdrOnStack < stackPointer()' failed.
* [Bugzilla 9451](/bug/9451) &mdash; Listing abstract functions in diagnostic should show full signature
* [Bugzilla 9473](/bug/9473) &mdash; Unittest docs should each be in their own section
* [Bugzilla 9474](/bug/9474) &mdash; Ddoc'd unittests should work correctly with interspersed version(none)
* [Bugzilla 9475](/bug/9475) &mdash; Should retain source formatting in ddoc's unittests
* [Bugzilla 9480](/bug/9480) &mdash; The template name in the JSON output contains template and function arguments
* [Bugzilla 9494](/bug/9494) &mdash; compiler stack overflow on invalid associative array
* [Bugzilla 9495](/bug/9495) &mdash; Win64 vararg issue when first argument is > 8 byte
* [Bugzilla 9508](/bug/9508) &mdash; RDMD doesn't generate new dependency list when a file is changed.
* [Bugzilla 9540](/bug/9540) &mdash; Compiler crash on delegate context frame assignment
* [Bugzilla 9561](/bug/9561) &mdash; Many error messages from std.format
* [Bugzilla 9590](/bug/9590) &mdash; UFCS does not work with void lazy expressions
* [Bugzilla 9613](/bug/9613) &mdash; Parser bug when using .init with type constructor
* [Bugzilla 9617](/bug/9617) &mdash; ulong.max is wrongly accepted by smaller signed parameter
* [Bugzilla 9619](/bug/9619) &mdash; Failed struct field typeof in inner function
* [Bugzilla 9622](/bug/9622) &mdash; Range violation in rdmd
* [Bugzilla 9649](/bug/9649) &mdash; DMD doesn't parse valid PostfixExpression . NewExpression syntax.
* [Bugzilla 9652](/bug/9652) &mdash; __traits(getAttributes) doesn't work with manifest constants
* [Bugzilla 9654](/bug/9654) &mdash; Template function cannot take string by ref T[len]
* [Bugzilla 9656](/bug/9656) &mdash; Built-in dup result should behave as like unique array, if it is possible.
* [Bugzilla 9658](/bug/9658) &mdash; Setting pre-initialized field should be allowed in qualified constructor.
* [Bugzilla 9677](/bug/9677) &mdash; Crash on setting length property of array VC 2012 64 bit
* [Bugzilla 9679](/bug/9679) &mdash; Refused const/immutable assignment in conditional
* [Bugzilla 9692](/bug/9692) &mdash; __traits(allMembers) fails on module without a package
* [Bugzilla 9700](/bug/9700) &mdash; std.typecons.Proxy with invaliant and in-place operation causes Access Violation
* [Bugzilla 9712](/bug/9712) &mdash; IFTI does not support deducing static array types from array literal arguments
* [Bugzilla 9713](/bug/9713) &mdash; Ddoc: Empty description suppress automatic example generation
* [Bugzilla 9714](/bug/9714) &mdash; Ddoc: Combination of -D and -unittest reveals hidden unittest function
* [Bugzilla 9720](/bug/9720) &mdash; OSX wrong code with -O Illegal instruction
* [Bugzilla 9722](/bug/9722) &mdash; optimizer kills GOT to EBX load
* [Bugzilla 9729](/bug/9729) &mdash; interface thunk doesn't set EBX to GOT
* [Bugzilla 9735](/bug/9735) &mdash; Casting delegates to void* should be illegal
* [Bugzilla 9736](/bug/9736) &mdash; VS2010 project file does full rebuild every time
* [Bugzilla 9743](/bug/9743) &mdash; IFTI and polymorphic string literal should support implicit conversion to static array type
* [Bugzilla 9744](/bug/9744) &mdash; Poor error message taking address of thread-local variable at compile time
* [Bugzilla 9747](/bug/9747) &mdash; IFTI argument deduction fails for committed string literals which are implicitly converted to a static array
* [Bugzilla 9755](/bug/9755) &mdash; JSON output is missing the protection attribute for templates
* [Bugzilla 9757](/bug/9757) &mdash; Ddoc: documented unittest after ditto should work
* [Bugzilla 9758](/bug/9758) &mdash; Ddoc: empty ddoc comment and unittest block generates no Examples section
* [Bugzilla 9768](/bug/9768) &mdash; No line number for wrong foreach type
* [Bugzilla 9773](/bug/9773) &mdash; ref parameter with default value should not compile
* [Bugzilla 9774](/bug/9774) &mdash; Error message with __error using == on tuple members
* [Bugzilla 9777](/bug/9777) &mdash; Calling final interface method leads to wrong code
* [Bugzilla 9781](/bug/9781) &mdash; -inline will cause backend ICE
* [Bugzilla 9788](/bug/9788) &mdash; -profile doesn't work if exceptions are thrown in the running program
* [Bugzilla 9790](/bug/9790) &mdash; Internal error when compiling a invalid variable in template (in expression.c and backend\evalu8.c)
* [Bugzilla 9791](/bug/9791) &mdash; [ICE] (struct.c line 668) map with a missing tuple import
* [Bugzilla 9818](/bug/9818) &mdash; Constant folding for static array does not work with initializing by element
* [Bugzilla 9829](/bug/9829) &mdash; rdmd passes '--' to dmd
* [Bugzilla 9837](/bug/9837) &mdash; IFTI should consider enum base type
* [Bugzilla 9844](/bug/9844) &mdash; DMD (-m64) int long initialisation bug
* [Bugzilla 9845](/bug/9845) &mdash; enum value should be able to contain forward references in global scope
* [Bugzilla 9863](/bug/9863) &mdash; Incorrect generation of SAHF instruction on 64 bits
* [Bugzilla 9873](/bug/9873) &mdash; Built-in tuple should support equality comparison
* [Bugzilla 9874](/bug/9874) &mdash; Function call syntax disuniformity in template constraints
* [Bugzilla 9880](/bug/9880) &mdash; Redundant template instance displaying in error message
* [Bugzilla 9883](/bug/9883) &mdash; Error on using property as new dynamic array size
* [Bugzilla 9885](/bug/9885) &mdash; IFTI should consider known tuple types.
* [Bugzilla 9892](/bug/9892) &mdash; [ICE] forward reference in enum declaration members causes compiler segfault
* [Bugzilla 9899](/bug/9899) &mdash; struct with pure/nothrow destructor cannot be used as a struct member in pure/nothrow functions
* [Bugzilla 9901](/bug/9901) &mdash; string return from inner template function error
* [Bugzilla 9907](/bug/9907) &mdash; Struct literal with destructor should match to non-ref overload
* [Bugzilla 9910](/bug/9910) &mdash; Scalar op vector is broken.
* [Bugzilla 9928](/bug/9928) &mdash; ice with void* and function literal
* [Bugzilla 9936](/bug/9936) &mdash; Wrong opBinary/opBinaryRight rewrite.
* [Bugzilla 9939](/bug/9939) &mdash; allMembers trait doesn't returns members of nested anonymous enum
* [Bugzilla 9940](/bug/9940) &mdash; ICE applying getProtection to a functions obtained using getOverloads.
* [Bugzilla 9946](/bug/9946) &mdash; A UFCS disallowed in dynamic array allocation
* [Bugzilla 9961](/bug/9961) &mdash; Using UFCS properties suppress actual errors
* [Bugzilla 9965](/bug/9965) &mdash; Wrong Assembly For DIL, SIL Registers
* [Bugzilla 9971](/bug/9971) &mdash; eponymous function is not an lvalue
* [Bugzilla 9985](/bug/9985) &mdash; Postblit isn't called on local struct return
* [Bugzilla 9990](/bug/9990) &mdash; templates with function alias cause forward reference error
* [Bugzilla 9993](/bug/9993) &mdash; const ctor should be preferred than mutable for const obj creation
* [Bugzilla 9994](/bug/9994) &mdash; Built-in generated opAssign should call dtor on assignment
* [Bugzilla 10004](/bug/10004) &mdash; tuple comparison with side-effect should work
* [Bugzilla 10005](/bug/10005) &mdash; struct variable declaration and const-correctness
* [Bugzilla 10011](/bug/10011) &mdash; Wrong JSON "init" property output for class reference initializers
* [Bugzilla 10029](/bug/10029) &mdash; Update list of reserved version identifiers.
* [Bugzilla 10058](/bug/10058) &mdash; Inconsistent mangling between C++ and extern(C++).
* [Bugzilla 10059](/bug/10059) &mdash; export doesn't work for variable declarations
* [Bugzilla 10063](/bug/10063) &mdash; inout+pure results in ability to produce immutable reference to mutable data
* [Bugzilla 10066](/bug/10066) &mdash; Template opEquals sometimes obstructs struct compilation
* [Bugzilla 10102](/bug/10102) &mdash; @disable incompletely implemented
* [Bugzilla 10103](/bug/10103) &mdash; template mixin with property overloads
* [Bugzilla 10105](/bug/10105) &mdash; ICE when converting string literal to static char array in enum initializer
* [Bugzilla 10115](/bug/10115) &mdash; More @disabled holes
* [Bugzilla 10171](/bug/10171) &mdash; Unexpected error "cannot infer type from overloaded function symbol"
* [Bugzilla 10180](/bug/10180) &mdash; offsetof doesn't work through function call alias this

## DMD Compiler Enhancements

* [Bugzilla 3449](/bug/3449) &mdash; const and invariant struct members do not behave according to spec
* [Bugzilla 3502](/bug/3502) &mdash; Fix for dropped Mac OS X 10.5
* [Bugzilla 3673](/bug/3673) &mdash; inheritance + if clause = no go
* [Bugzilla 4528](/bug/4528) &mdash; Better error message for private abstract method
* [Bugzilla 5140](/bug/5140) &mdash; Add __FUNCTION__, __PRETTY_FUNCTION__, and __MODULE__
* [Bugzilla 6185](/bug/6185) &mdash; Include non-global functions when resolving UFCS
* [Bugzilla 6453](/bug/6453) &mdash; Allow multiple invariant per struct/class
* [Bugzilla 6809](/bug/6809) &mdash; IFTI should imply const where inout is present on args, but not on return type
* [Bugzilla 7444](/bug/7444) &mdash; Require [] for array copies too
* [Bugzilla 7511](/bug/7511) &mdash; attribute inference should work for template functions
* [Bugzilla 8220](/bug/8220) &mdash; invalid function call not detected during semantic analysis
* [Bugzilla 8669](/bug/8669) &mdash; TemplateThisParameter should change member function's qualifier
* [Bugzilla 8819](/bug/8819) &mdash; void static array should have init built-in propert
* [Bugzilla 8959](/bug/8959) &mdash; IsExpression should support syntax which has no Identifier in all cases
* [Bugzilla 9033](/bug/9033) &mdash; Remove __thread from the language
* [Bugzilla 9136](/bug/9136) &mdash; Add isNested trait
* [Bugzilla 9155](/bug/9155) &mdash; Ddoc: code section should strip leading spaces
* [Bugzilla 9170](/bug/9170) &mdash; CTFE: Allow reinterpret casts float <-> int
* [Bugzilla 9185](/bug/9185) &mdash; Add note about where -op is useful
* [Bugzilla 9574](/bug/9574) &mdash; Diagnostic for old use of 'alias this = that' should be informative
* [Bugzilla 9627](/bug/9627) &mdash; Not good enough error messages in some cases when using UFCS
* [Bugzilla 9635](/bug/9635) &mdash; Improved error message for failed access of array field properties from static method
* [Bugzilla 9676](/bug/9676) &mdash; Ddoc: Wrap deprecated declarations in a (DEPRECATED) macro
* [Bugzilla 9680](/bug/9680) &mdash; Include entry point location in "dmd -v -o-" output
* [Bugzilla 9723](/bug/9723) &mdash; Implement -main switch to inject a default main() function
* [Bugzilla 9726](/bug/9726) &mdash; Add minimum % coverage required for -cov testing
* [Bugzilla 9727](/bug/9727) &mdash; Documented unittest comment should appear before Example section
* [Bugzilla 9745](/bug/9745) &mdash; Allow non-thread local static variables to have their address taken in CTFE
* [Bugzilla 9778](/bug/9778) &mdash; RDMD: Support passing resource files to DMD
* [Bugzilla 9789](/bug/9789) &mdash; Ddoc for aliases should use new "alias x=y" syntax
* [Bugzilla 9866](/bug/9866) &mdash; movsxd not supported
* [Bugzilla 9920](/bug/9920) &mdash; [Optimizer] Use mul/imul for integer division by constant
* [Bugzilla 9941](/bug/9941) &mdash; [CTFE] Allow to store "newed" classes and structs in the data segment
* [Bugzilla 9943](/bug/9943) &mdash; Allow to return typeid from CTFE
* [Bugzilla 9963](/bug/9963) &mdash; Absurdly Inefficient Codegen For Adding Boolean Predicates
* [Bugzilla 9977](/bug/9977) &mdash; Function local templates should be allowed
* [Bugzilla 10030](/bug/10030) &mdash; Support '-l:' switch when passing default library to ld
* [Bugzilla 10077](/bug/10077) &mdash; add pragma(mangle, "...") to override symbol mangle.
* [Bugzilla 10109](/bug/10109) &mdash; add -transition compiler switch to aid in dealing with breaking changes
* [Bugzilla 10150](/bug/10150) &mdash; Prefix method 'this' qualifiers should be just ignored anytime
* [Bugzilla 10179](/bug/10179) &mdash; Tuple assignment should not cause "has no effect" error even if the length is zero

## Phobos Regressions

* [Bugzilla 9122](/bug/9122) &mdash; std.concurrency send() fails with multiple arrays
* [Bugzilla 9742](/bug/9742) &mdash; std.math.floor returns 0 for any value x > -1 and x < 0
* [Bugzilla 10122](/bug/10122) &mdash; `Appender` doesn't work with disabled default construction

## Phobos Bugs Fixed

* [Bugzilla 3795](/bug/3795) &mdash; Problem with phobos std.variant
* [Bugzilla 4729](/bug/4729) &mdash; std.algorithm: strange iota behaviour
* [Bugzilla 4798](/bug/4798) &mdash; std.algorithm.map unusable for ranges with const elements
* [Bugzilla 4955](/bug/4955) &mdash; struct dirent.d_type is not a mask
* [Bugzilla 5032](/bug/5032) &mdash; std.file.rename acts differently on Windows and Linux when the target file already exists.
* [Bugzilla 5201](/bug/5201) &mdash; std.string.indexOf and std.algorithm.indexOf return different things for narrow strings
* [Bugzilla 5310](/bug/5310) &mdash; Variant == const(Variant) doesn't compile
* [Bugzilla 5359](/bug/5359) &mdash; std.traits.isDelegate should work for types and expressions
* [Bugzilla 5360](/bug/5360) &mdash; calling rdmd from different folder
* [Bugzilla 5514](/bug/5514) &mdash; Erroneous documentation and lacking randomization for topN
* [Bugzilla 5658](/bug/5658) &mdash; Undocumented fields in std.typecons.Tuple
* [Bugzilla 5924](/bug/5924) &mdash; schwartzSort of Tuple!(char)[]
* [Bugzilla 8321](/bug/8321) &mdash; std.range.put doesn't work with RefCounted output range
* [Bugzilla 8613](/bug/8613) &mdash; std.typecons.Proxy cannot work with operator 'in'
* [Bugzilla 8655](/bug/8655) &mdash; bitfields and Typedef don't mix
* [Bugzilla 9164](/bug/9164) &mdash; Can't easily assign one Nullable to another
* [Bugzilla 9431](/bug/9431) &mdash; Tuple creation problem with array of array
* [Bugzilla 9456](/bug/9456) &mdash; decodeFront is inconsistent in whether it pops elements off of the range or not
* [Bugzilla 9512](/bug/9512) &mdash; std.regex: Incorrect parsing of hex sequences composed from capital letters.
* [Bugzilla 9553](/bug/9553) &mdash; SOCKET should be 64 bit wide on Win64
* [Bugzilla 9583](/bug/9583) &mdash; std.getopt.getopt does not consume options terminator "--" from args list, as docs claim
* [Bugzilla 9612](/bug/9612) &mdash; std.range.Cycle.opSlice tests on the bounds are missing
* [Bugzilla 9624](/bug/9624) &mdash; fullyQualifiedName fails for functions
* [Bugzilla 9648](/bug/9648) &mdash; Missing std.random import for std.algorithm.topN
* [Bugzilla 9753](/bug/9753) &mdash; std.string.translate precondition asserts
* [Bugzilla 9794](/bug/9794) &mdash; std.json cannot handle delete character
* [Bugzilla 9804](/bug/9804) &mdash; `std.math.FloatingPointControl` corrupts floating point state
* [Bugzilla 9812](/bug/9812) &mdash; std.conv.parse string fails on certain escape characters.
* [Bugzilla 9836](/bug/9836) &mdash; std.array.popFront does not work with alias this.
* [Bugzilla 9950](/bug/9950) &mdash; std.json should return empty string/array instead of null on empty input
* [Bugzilla 9956](/bug/9956) &mdash; hasElaborateAssign trait does not work with static arrays
* [Bugzilla 9979](/bug/9979) &mdash; Regex bug with \b and look-behind
* [Bugzilla 10116](/bug/10116) &mdash; stdio.File.byLine repeats last line forever, readln(ref C[],R) returns bad data
* [Bugzilla 10167](/bug/10167) &mdash; Wrong Document Comment on std.format.d(181)
* [Bugzilla 10182](/bug/10182) &mdash; std.bitmanip unit test has pointless/unused foreach loop

## Phobos Enhancements

* [Bugzilla 4787](/bug/4787) &mdash; std.algorithm.bisectRight()
* [Bugzilla 4921](/bug/4921) &mdash; Synopsis code in std.variant documentation throws an assertion error
* [Bugzilla 5013](/bug/5013) &mdash; std.typecons.Tuple should have constructor for static arrays
* [Bugzilla 5106](/bug/5106) &mdash; makeIndex should return SortedRange
* [Bugzilla 5226](/bug/5226) &mdash; indexOf() which takes a pred but no needle
* [Bugzilla 5401](/bug/5401) &mdash; std.socket updates and boost license
* [Bugzilla 5507](/bug/5507) &mdash; countUntil should take Ranges... instead of R2
* [Bugzilla 6224](/bug/6224) &mdash; Add an ownerTid property in std.concurrency
* [Bugzilla 6486](/bug/6486) &mdash; std.math.abs(BigInt)
* [Bugzilla 7405](/bug/7405) &mdash; std.algorithm.schwartzSort.release
* [Bugzilla 9260](/bug/9260) &mdash; getopt should allow setting booleans to false
* [Bugzilla 9265](/bug/9265) &mdash; Nullable fixed-sized array wrapper
* [Bugzilla 9625](/bug/9625) &mdash; assertNotThrown should print exception msg if no msg is provided
* [Bugzilla 9802](/bug/9802) &mdash; Add `std.traits.{isNested,hasNested}`.
* [Bugzilla 9814](/bug/9814) &mdash; Add std.traits.isNestedFunction
* [Bugzilla 9839](/bug/9839) &mdash; std.traits.Select should be able to select symbols
* [Bugzilla 9888](/bug/9888) &mdash; Allow passing a generator to std.random.uniform for enums

## druntime Bugs Fixed

* [Bugzilla 4307](/bug/4307) &mdash; spawn()'ed thread doesn't terminate
* [Bugzilla 6024](/bug/6024) &mdash; Document that Windows 2000 SP4 is no longer supported
* [Bugzilla 10057](/bug/10057) &mdash; [2.063 beta] Module info overwritten in shared phobos.
* [Bugzilla 10081](/bug/10081) &mdash; Incorrect char array comparison

## Optlink Bugs Fixed

* [Bugzilla 6144](/bug/6144) &mdash; Unexpected OPTLINK Termination at EIP=00428DA3

## Installer Bugs Fixed

* [Bugzilla 9343](/bug/9343) &mdash; Problem installing dmd-2.061-0.fedora.x86_64.rpm on Fedora 18

## Website Bugs Fixed

* [Bugzilla 4847](/bug/4847) &mdash; std.algorithm.topN documentation
* [Bugzilla 9544](/bug/9544) &mdash; D logo image is broken on non-root-level pages
* [Bugzilla 9609](/bug/9609) &mdash; Ddoc tags for std.string.icmp seem wrong
* [Bugzilla 10036](/bug/10036) &mdash; missing core.atomic docs on dlang.org
